<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MEG Audification</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üß≤</text></svg>">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=IBM+Plex+Mono:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e;
            color: #e0e0e0;
            padding: 24px;
        }
        h1 {
            margin-bottom: 24px;
            color: #5FB3B3;
            font-weight: 700;
            font-size: 24px;
            letter-spacing: -0.5px;
        }
        .controls {
            display: flex;
            gap: 16px;
            margin-bottom: 16px;
            flex-wrap: wrap;
            align-items: center;
        }
        select, button {
            padding: 8px 16px;
            font-size: 14px;
            font-family: 'Inter', sans-serif;
            font-weight: 500;
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.15s ease;
        }
        select {
            background: #2a2a4a;
            color: #e0e0e0;
        }
        select:hover { border-color: rgba(255,255,255,0.2); }
        button {
            background: #4a8a8a;
            color: #fff;
            font-weight: 600;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        button:hover {
            background: #5a9a9a;
            box-shadow: 0 2px 6px rgba(0,0,0,0.4);
        }
        button:active {
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.4);
            transform: translateY(1px);
        }
        button:disabled {
            background: #3a3a4a;
            color: #666;
            cursor: not-allowed;
            box-shadow: none;
            border-color: rgba(255,255,255,0.05);
        }
        @keyframes pulse-glow {
            0%, 100% { box-shadow: 0 2px 4px rgba(0,0,0,0.3); background: #4a8a8a; }
            50% { box-shadow: 0 0 18px rgba(95,179,179,0.7); background: #5FB3B3; }
        }
        .pulse { animation: pulse-glow 1.5s ease-in-out infinite; }
        .info {
            background: #2a2a4a;
            padding: 16px;
            border-radius: 4px;
            border: 1px solid rgba(255,255,255,0.1);
            font-family: 'IBM Plex Mono', monospace;
            font-size: 12px;
            color: rgba(224,224,224,0.7);
            min-height: 80px;
            max-height: 80px;
            margin-bottom: 0;
        }
        .info strong {
            color: #e0e0e0;
            font-weight: 600;
        }
        .data-display {
            display: flex;
            gap: 16px;
            margin-bottom: 24px;
        }
        .sensor-map {
            flex-shrink: 0;
            width: 715px;
            aspect-ratio: 1056 / 992;
            background: #0a0a1a;
            border-radius: 4px;
            border: 1px solid rgba(255,255,255,0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 8px;
        }
        .sensor-map img {
            width: 100%;
            height: auto;
            border-radius: 2px;
        }
        #waveformContainer {
            background: #0a0a1a;
            border-radius: 4px;
            border: 1px solid rgba(255,255,255,0.1);
            overflow: hidden;
        }
        canvas { display: block; width: 100%; }
        input[type="range"] { opacity: 0.5; }
        .time-indicator {
            display: flex;
            justify-content: space-between;
            padding: 8px 16px;
            background: #2a2a4a;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 12px;
            color: rgba(224,224,224,0.7);
        }
        .status {
            padding: 8px 16px;
            background: #2a2a4a;
            border-radius: 4px;
            margin-bottom: 16px;
        }
        #seekSlider { width: 100%; margin: 8px 0; }
        .cache-indicator {
            display: flex;
            gap: 2px;
            margin: 8px 0;
            height: 16px;
        }
        .chunk-bar {
            flex: 1;
            background: #333;
            border-radius: 2px;
            transition: background 0.2s;
        }
        .chunk-bar.loaded { background: #5FB3B3; }
        .chunk-bar.loading { background: #d4a057; }
        .chunk-bar.current { box-shadow: 0 0 5px #fff; }

        /* Upload section */
        .channel-selector {
            max-height: 200px;
            overflow-y: auto;
            background: #2a2a4a;
            padding: 8px;
            border-radius: 4px;
            margin-bottom: 8px;
        }
        .channel-selector label {
            display: inline-block;
            padding: 2px 8px;
            margin: 2px;
            background: #3a3a5a;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
        }
        .channel-selector input:checked + span {
            color: #5FB3B3;
        }
        .quick-select {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-bottom: 8px;
        }
        .quick-select button {
            padding: 4px 8px;
            font-size: 12px;
            background: #3a3a5a;
        }

        /* Tabs - commented out, see upload code below
        .tabs { display: flex; gap: 4px; margin-bottom: 16px; }
        .tab { padding: 8px 16px; background: #2a2a4a; border: 1px solid rgba(255,255,255,0.1); border-radius: 4px 4px 0 0; color: #888; cursor: pointer; font-size: 14px; transition: all 0.15s; }
        .tab:hover { background: #3a3a5a; color: #ccc; }
        .tab.active { background: #5FB3B3; color: #1a1a2e; font-weight: bold; }
        .tab-content { display: none; padding: 16px; background: #2a2a4a; border-radius: 0 4px 4px 4px; margin-bottom: 16px; }
        .tab-content.active { display: block; }
        */
    </style>
</head>
<body>
    <h1>MEG Audification Explorer</h1>

    <!-- Region selector (demo data) -->
    <div class="controls">
        <select id="regionSelect">
            <option value="">Loading regions...</option>
        </select>
        <button id="loadBtn" disabled>Load Region</button>
        <button id="playBtn" disabled>Play</button>
        <button id="stopBtn" disabled>Stop</button>
        <span style="color: rgba(255,255,255,0.15); margin: 0 8px;">|</span>
        <button id="preloadToggle" style="background: #4a7a5a; font-size: 12px; width: 160px; text-align: center;">Preload: Auto</button>
        <span id="cacheStatus" style="color: rgba(224,224,224,0.5); font-size: 12px; font-family: 'IBM Plex Mono', monospace; margin-left: 8px;"></span>
    </div>

    <!--
    ============================================================
    COMMENTED OUT: Browser-based .mat upload

    Reason: Large files (1 hour MEG = ~4GB) exceed browser memory.
    For now, datasets are curated via scripts/export_regions.py.
    This code is preserved for potential future use with smaller files
    or if we add server-side processing.
    ============================================================

    <div class="tabs">
        <button class="tab active" id="tabDemo">Demo Data</button>
        <button class="tab" id="tabUpload">Upload .mat File</button>
        <input type="file" id="fileInput" accept=".mat" style="display: none;">
    </div>

    <div class="tab-content active" id="contentDemo">
        <div class="controls">
            <select id="regionSelect">
                <option value="">Loading regions...</option>
            </select>
            <button id="loadBtn" disabled>Load Region</button>
        </div>
    </div>

    <div class="tab-content" id="contentUpload">
        <div style="margin-bottom: 10px;">
            <span id="uploadStatus" style="color: #888;">Click the tab above to select a .mat file</span>
        </div>
        <div id="uploadControls" style="display: none;">
            <div class="quick-select">
                <span style="color: #888;">Quick select:</span>
                <button onclick="selectChannelRange(0, 50)">First 50</button>
                <button onclick="selectChannelRange(0, 100)">First 100</button>
                <button onclick="selectAllChannels()">All MEG</button>
                <button onclick="selectNoChannels()">Clear</button>
            </div>
            <div class="channel-selector" id="channelSelector"></div>
            <button id="loadUploadedBtn">Load Selected Channels</button>
        </div>
    </div>
    -->

    <div id="status" style="display:none;"></div>
    <div style="display: flex; gap: 16px; margin-bottom: 16px;">
        <div class="info" id="info" style="flex-shrink: 0; width: 715px;">
                <strong>No Region Loaded</strong><br>
                Channels: 0 | Duration: 0s | Sample rate: N/A<br>
                <span style="color: #5FB3B3;">Chunk size: N/A | 0 total chunks</span>
        </div>
        <div id="spectrumContainer" style="flex: 1; background: #0a0a1a; border-radius: 4px; border: 1px solid rgba(255,255,255,0.1); min-height: 80px; max-height: 80px; min-width: 0;">
            <canvas id="spectrum"></canvas>
        </div>
    </div>

    <div class="data-display">
        <div class="sensor-map">
            <img id="sensorImg" src="sensor_layout.jpeg" alt="Neuromag MEG sensor layout">
        </div>
        <div style="flex: 1; min-width: 0; display: flex; flex-direction: column; gap: 8px;">
            <div>
                <input type="range" id="seekSlider" min="0" max="133" value="0" step="0.1" style="width: 100%;">
                <div id="cacheIndicator" style="display:none;"></div>
                <span id="currentTime" style="display:none;">0.00s</span>
                <span id="totalTime" style="display:none;">133.00s</span>
            </div>
            <div id="waveformContainer">
                <canvas id="waveform"></canvas>
            </div>
        </div>
    </div>
    <div style="display: flex; gap: 16px; margin-top: -16px; margin-bottom: 24px;">
        <div style="flex-shrink: 0; width: 715px;"></div>
        <div style="display: flex; align-items: center; gap: 8px;">
            <span style="color: rgba(224,224,224,0.5); font-size: 12px; font-family: 'IBM Plex Mono', monospace; white-space: nowrap;">Gain: <span id="gainValue">2.00</span>√ó</span>
            <input type="range" id="gainSlider" min="1" max="5" value="2" step="0.01"
                   style="flex: 1; max-width: 300px;">
        </div>
    </div>

    <script>
        /*
        ============================================================
        COMMENTED OUT: MAT v5 Parser for browser-based upload

        Reason: Large files exceed browser memory. See upload code below.
        ============================================================

        const MatParser = {
            TYPES: { 1: 'int8', 2: 'uint8', 3: 'int16', 4: 'uint16', 5: 'int32', 6: 'uint32', 7: 'float32', 9: 'float64', 12: 'int64', 13: 'uint64', 14: 'matrix', 15: 'compressed', 16: 'utf8', 17: 'utf16', 18: 'utf32' },
            read(arrayBuffer) { ... },
            readElement(view, offset) { ... },
            readMatrix(view, offset, totalSize, nextOffset) { ... },
            skipSubelement(view, offset) { ... },
            readDimensions(view, offset) { ... },
            readName(view, offset) { ... },
            readNumericData(view, offset, dimensions) { ... },
            transpose(arr) { ... }
        };
        */

        // ===== CONFIGURATION =====
        const DATA_BASE_URL = '../data/processed/regions';
        const CHUNK_DURATION = 5;  // seconds per chunk
        const PREFETCH_AHEAD = 2;   // prefetch this many chunks ahead

        // ===== STATE =====
        let metadata = null;
        let regionData = null;
        let audioContext = null;
        let audioSource = null;
        let isPlaying = false;
        let playStartTime = 0;
        let playStartOffset = 0;

        // Chunk cache: Map<chunkIndex, Float32Array>
        let chunkCache = new Map();
        let loadingChunks = new Set();  // Currently fetching
        let isUploadedData = false;  // True when using uploaded .mat file
        let preloadMode = 'auto';  // 'auto' = prefetch all, 'ondemand' = fetch only when needed
        let selectedChannels = new Set();  // Channels selected for audification

        // ===== DOM ELEMENTS =====
        const regionSelect = document.getElementById('regionSelect');
        const loadBtn = document.getElementById('loadBtn');
        const playBtn = document.getElementById('playBtn');
        const stopBtn = document.getElementById('stopBtn');
        const status = document.getElementById('status');
        const info = document.getElementById('info');
        const canvas = document.getElementById('waveform');
        const ctx = canvas.getContext('2d');
        const seekSlider = document.getElementById('seekSlider');
        const currentTimeEl = document.getElementById('currentTime');
        const totalTimeEl = document.getElementById('totalTime');
        const cacheIndicator = document.getElementById('cacheIndicator');
        const preloadToggle = document.getElementById('preloadToggle');
        const spectrumCanvas = document.getElementById('spectrum');
        const specCtx = spectrumCanvas.getContext('2d');

        // ===== CHUNK MANAGEMENT =====

        function getChunkIndex(timeSec) {
            return Math.floor(timeSec / CHUNK_DURATION);
        }

        function getChunkTimeRange(chunkIndex) {
            const start = chunkIndex * CHUNK_DURATION;
            const end = Math.min(start + CHUNK_DURATION, regionData?.duration_seconds || 133);
            return { start, end };
        }

        function getTotalChunks() {
            if (!regionData) return 0;
            return Math.ceil(regionData.duration_seconds / CHUNK_DURATION);
        }

        // Fetch a single chunk by index
        async function fetchChunk(chunkIndex) {
            if (!regionData) return null;
            if (chunkCache.has(chunkIndex)) return chunkCache.get(chunkIndex);
            if (loadingChunks.has(chunkIndex)) return null;  // Already loading

            const { start, end } = getChunkTimeRange(chunkIndex);
            if (start >= regionData.duration_seconds) return null;

            loadingChunks.add(chunkIndex);
            updateCacheIndicator();

            const bytesPerSample = regionData.n_channels * 4;
            const samplesPerSec = regionData.sample_rate;
            const startByte = Math.floor(start * samplesPerSec * bytesPerSample);
            const endByte = Math.floor(end * samplesPerSec * bytesPerSample);

            console.log(`üì¶ Fetching chunk ${chunkIndex} (${start}s-${end}s): bytes ${startByte}-${endByte}`);

            try {
                const response = await fetch(`${DATA_BASE_URL}/${regionData.file}`, {
                    headers: { 'Range': `bytes=${startByte}-${endByte - 1}` }
                });

                if (response.status === 206) {
                    console.log(`‚úÖ Chunk ${chunkIndex}: 206 Partial Content`);
                } else {
                    console.warn(`‚ö†Ô∏è Chunk ${chunkIndex}: ${response.status} (Range not supported?)`);
                }

                const buffer = await response.arrayBuffer();
                const data = new Float32Array(buffer);

                chunkCache.set(chunkIndex, data);
                loadingChunks.delete(chunkIndex);
                updateCacheIndicator();

                return data;
            } catch (err) {
                console.error(`‚ùå Chunk ${chunkIndex} failed:`, err);
                loadingChunks.delete(chunkIndex);
                updateCacheIndicator();
                return null;
            }
        }

        // Fetch ALL chunks sequentially in background
        async function fetchAllChunks() {
            const totalChunks = getTotalChunks();
            for (let i = 0; i < totalChunks; i++) {
                if (!chunkCache.has(i) && !loadingChunks.has(i)) {
                    await fetchChunk(i);
                }
            }
            document.getElementById('cacheStatus').textContent = `All ${totalChunks} chunks loaded!`;
        }

        // Get data for a time range (from cache or fetch)
        async function getDataForTimeRange(startSec, endSec) {
            // For uploaded data, all data is in chunk 0
            if (isUploadedData) {
                const fullData = chunkCache.get(0);
                if (!fullData) return null;
                const offsetStart = Math.floor(startSec * regionData.sample_rate) * regionData.n_channels;
                const offsetEnd = Math.floor(endSec * regionData.sample_rate) * regionData.n_channels;
                return fullData.slice(offsetStart, Math.min(offsetEnd, fullData.length));
            }

            const startChunk = getChunkIndex(startSec);
            const endChunk = getChunkIndex(endSec - 0.001);  // Avoid edge case

            // Collect all needed chunks
            const chunks = [];
            for (let i = startChunk; i <= endChunk; i++) {
                let data = chunkCache.get(i);
                if (!data) {
                    data = await fetchChunk(i);
                }
                if (data) chunks.push({ index: i, data });
            }

            if (chunks.length === 0) return null;

            // If single chunk, slice to exact range
            if (chunks.length === 1) {
                const chunk = chunks[0];
                const chunkStart = chunk.index * CHUNK_DURATION;
                const offsetStart = Math.floor((startSec - chunkStart) * regionData.sample_rate) * regionData.n_channels;
                const offsetEnd = Math.floor((endSec - chunkStart) * regionData.sample_rate) * regionData.n_channels;
                return chunk.data.slice(offsetStart, Math.min(offsetEnd, chunk.data.length));
            }

            // Multiple chunks - concatenate
            // First, calculate actual total size by summing slices
            let totalSize = 0;
            const slices = [];

            for (const chunk of chunks) {
                const chunkStart = chunk.index * CHUNK_DURATION;
                const chunkEnd = Math.min(chunkStart + CHUNK_DURATION, regionData.duration_seconds);

                const sliceStart = Math.max(startSec, chunkStart);
                const sliceEnd = Math.min(endSec, chunkEnd);

                const offsetStart = Math.floor((sliceStart - chunkStart) * regionData.sample_rate) * regionData.n_channels;
                const offsetEnd = Math.floor((sliceEnd - chunkStart) * regionData.sample_rate) * regionData.n_channels;

                const slice = chunk.data.slice(offsetStart, Math.min(offsetEnd, chunk.data.length));
                slices.push(slice);
                totalSize += slice.length;
            }

            // Now allocate and copy
            const result = new Float32Array(totalSize);
            let writeOffset = 0;
            for (const slice of slices) {
                result.set(slice, writeOffset);
                writeOffset += slice.length;
            }

            return result;
        }

        // Update cache indicator UI
        function updateCacheIndicator() {
            const totalChunks = getTotalChunks();
            if (!totalChunks) return;

            cacheIndicator.innerHTML = '';
            for (let i = 0; i < totalChunks; i++) {
                const bar = document.createElement('div');
                bar.className = 'chunk-bar';
                if (chunkCache.has(i)) bar.classList.add('loaded');
                if (loadingChunks.has(i)) bar.classList.add('loading');
                bar.title = `Chunk ${i}: ${i * CHUNK_DURATION}s - ${(i + 1) * CHUNK_DURATION}s`;
                cacheIndicator.appendChild(bar);
            }
        }

        // ===== INITIALIZATION =====

        async function init() {
            try {
                const response = await fetch(`${DATA_BASE_URL}/metadata.json`);
                metadata = await response.json();

                regionSelect.innerHTML = '<option value="">Select a region...</option>';
                for (const [key, region] of Object.entries(metadata.regions)) {
                    const opt = document.createElement('option');
                    opt.value = key;
                    opt.textContent = `${region.description} (${region.n_channels} ch)`;
                    regionSelect.appendChild(opt);
                }

                // Default to left occipital
                if (metadata.regions['left_occipital']) {
                    regionSelect.value = 'left_occipital';
                }

                // Enter key triggers load
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' && regionSelect.value && !loadBtn.disabled) {
                        loadRegion();
                    }
                });

                loadBtn.disabled = false;
                loadBtn.classList.add('pulse');
                document.getElementById('cacheStatus').textContent = 'Ready. Press Enter or click Load.';
            } catch (err) {
                document.getElementById('cacheStatus').textContent = `Error: ${err.message}`;
                console.error(err);
            }
        }

        // ===== LOAD REGION =====

        async function loadRegion() {
            loadBtn.classList.remove('pulse');
            const regionKey = regionSelect.value;
            if (!regionKey) return;

            const region = metadata.regions[regionKey];
            status.textContent = `Loading ${region.description}...`;
            loadBtn.disabled = true;

            // Reset cache
            chunkCache = new Map();
            loadingChunks = new Set();
            isUploadedData = false;

            regionData = { ...region };

            // Update sensor map image based on region
            const sensorImg = document.getElementById('sensorImg');
            sensorImg.src = regionKey === 'left_occipital'
                ? 'Neuromag_MEG_sensor_layout_Black_L_Occipital_Highlight.jpg'
                : 'sensor_layout.jpeg';

            // Default-select MEG1732 if present in this region
            selectedChannels = new Set();
            if (region.channels) {
                const idx = region.channels.indexOf('MEG1732');
                if (idx !== -1) selectedChannels.add(idx);
            }

            const totalChunks = getTotalChunks();
            const bytesPerChunk = CHUNK_DURATION * region.sample_rate * region.n_channels * 4;

            info.innerHTML = `
                <strong>${region.description}</strong><br>
                Channels: ${region.n_channels} | Duration: ${region.duration_seconds}s | Sample rate: ${region.sample_rate} Hz<br>
                <span style="color: #5FB3B3;">Chunk size: ${CHUNK_DURATION}s (${(bytesPerChunk/1024).toFixed(0)} KB) | ${totalChunks} total chunks</span>
            `;

            // Setup canvas
            canvas.width = canvas.offsetWidth * window.devicePixelRatio;
            const canvasH = Math.min(region.n_channels * 26.5, 900);
            canvas.height = canvasH * window.devicePixelRatio;
            canvas.style.height = `${canvasH}px`;

            // Setup cache indicator
            updateCacheIndicator();

            // Fetch first chunk and draw immediately
            await fetchChunk(0);
            await drawTimeRange(0, 5);

            // Start background fetch of ALL remaining chunks (if auto mode)
            if (preloadMode === 'auto') {
                fetchAllChunks();
            }

            playBtn.disabled = false;
            stopBtn.disabled = false;
            loadBtn.disabled = false;
            document.getElementById('cacheStatus').textContent = 'Loaded. Streaming chunks.';
        }

        // ===== DRAWING =====

        async function drawTimeRange(startSec, durationSec) {
            if (!regionData) return;

            const endSec = Math.min(startSec + durationSec, regionData.duration_seconds);
            const data = await getDataForTimeRange(startSec, endSec);

            if (!data || data.length === 0) {
                status.textContent = `No data for ${startSec.toFixed(1)}s - ${endSec.toFixed(1)}s`;
                return;
            }

            const nChannels = regionData.n_channels;
            const nSamples = data.length / nChannels;
            const width = canvas.width;
            const height = canvas.height;
            const channelHeight = height / nChannels;
            const labelWidth = 70 * window.devicePixelRatio;  // Left margin for labels
            const waveformWidth = width - labelWidth;
            const displayGain = parseFloat(document.getElementById('gainSlider').value);

            ctx.fillStyle = '#0a0a1a';
            ctx.fillRect(0, 0, width, height);

            // Draw each channel
            for (let ch = 0; ch < nChannels; ch++) {
                const y = ch * channelHeight + channelHeight / 2;
                const color = `hsl(${(ch * 360 / nChannels)}, 70%, 60%)`;

                // Channel label on left
                const chName = regionData.channels?.[ch] || `CH${ch}`;
                const shortName = chName.replace('MEG', '');  // "MEG2112" -> "2112"
                const isSelected = selectedChannels.has(ch);
                if (isSelected) {
                    ctx.fillStyle = color;
                    ctx.font = `bold ${10 * window.devicePixelRatio}px monospace`;
                    ctx.shadowColor = color;
                    ctx.shadowBlur = 6 * window.devicePixelRatio;
                } else {
                    ctx.fillStyle = '#555';
                    ctx.font = `${10 * window.devicePixelRatio}px monospace`;
                    ctx.shadowColor = 'transparent';
                    ctx.shadowBlur = 0;
                }
                ctx.textAlign = 'right';
                ctx.textBaseline = 'middle';
                ctx.fillText(shortName, labelWidth - 15 * window.devicePixelRatio, y);
                ctx.shadowColor = 'transparent';
                ctx.shadowBlur = 0;

                // Dash line connecting label to waveform
                ctx.strokeStyle = '#444';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(labelWidth - 10 * window.devicePixelRatio, y);
                ctx.lineTo(labelWidth, y);
                ctx.stroke();

                // Baseline
                ctx.strokeStyle = '#222';
                ctx.beginPath();
                ctx.moveTo(labelWidth, y);
                ctx.lineTo(width, y);
                ctx.stroke();

                // Waveform
                ctx.strokeStyle = isSelected ? color : 'rgba(255,255,255,0.5)';
                ctx.lineWidth = isSelected ? 1.5 : 1;
                ctx.beginPath();

                const samplesPerPixel = nSamples / waveformWidth;

                for (let px = 0; px < waveformWidth; px++) {
                    const sampleIdx = Math.floor(px * samplesPerPixel);
                    const dataIdx = sampleIdx * nChannels + ch;

                    if (dataIdx < data.length) {
                        const value = data[dataIdx];
                        const normalized = value / 1e-10 * displayGain;
                        const yPos = y - normalized * (channelHeight * 0.4);

                        if (px === 0) ctx.moveTo(labelWidth + px, yPos);
                        else ctx.lineTo(labelWidth + px, yPos);
                    }
                }
                ctx.stroke();
            }

            // Eyes-closed marker
            if (startSec <= 74 && endSec >= 74) {
                const markerX = labelWidth + ((74 - startSec) / durationSec) * waveformWidth;
                ctx.strokeStyle = '#ff4444';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(markerX, 0);
                ctx.lineTo(markerX, height);
                ctx.stroke();
                ctx.fillStyle = '#ff4444';
                ctx.font = `${12 * window.devicePixelRatio}px sans-serif`;
                ctx.textAlign = 'left';
                ctx.fillText('Eyes Closed', markerX + 5, 15 * window.devicePixelRatio);
            }

            // Time range label (lower right)
            ctx.fillStyle = '#666';
            ctx.font = `${11 * window.devicePixelRatio}px monospace`;
            ctx.textAlign = 'right';
            ctx.fillText(`${startSec.toFixed(1)}s - ${endSec.toFixed(1)}s`, width - 10 * window.devicePixelRatio, height - 10 * window.devicePixelRatio);

            // Update current chunk highlight
            const currentChunk = getChunkIndex(startSec);
            document.querySelectorAll('.chunk-bar').forEach((bar, i) => {
                bar.classList.toggle('current', i === currentChunk);
            });

            // Update power spectrum
            drawSpectrum(data, nChannels, regionData.sample_rate);
        }

        // ===== PLAYBACK =====
        // Play 1000 Hz MEG data at 44100 Hz = 44.1x frequency shift
        // 10 Hz alpha ‚Üí 441 Hz (audible!)
        // 5 seconds of MEG ‚Üí ~0.11 seconds of audio

        async function playAudio() {
            if (!regionData) return;

            // Get current visible time range from slider
            const currentTime = parseFloat(seekSlider.value);
            const startSec = Math.max(0, currentTime - 2.5);
            const endSec = Math.min(startSec + CHUNK_DURATION, regionData.duration_seconds);
            const playDuration = endSec - startSec;

            status.textContent = `Loading audio for ${startSec.toFixed(1)}s - ${endSec.toFixed(1)}s...`;

            // Fetch the data for this range (will use cache if available)
            const data = await getDataForTimeRange(startSec, endSec);

            if (!data || data.length === 0) {
                status.textContent = 'No data available for this range';
                return;
            }

            const nChannels = regionData.n_channels;
            const nSamples = Math.floor(data.length / nChannels);

            if (selectedChannels.size === 0) {
                status.textContent = 'No channels selected. Click channel labels to select.';
                return;
            }
            const activeChannels = [...selectedChannels];
            const nActive = activeChannels.length;

            const mono = new Float32Array(nSamples);
            for (let s = 0; s < nSamples; s++) {
                let sum = 0;
                for (let i = 0; i < nActive; i++) {
                    sum += data[s * nChannels + activeChannels[i]];
                }
                mono[s] = sum / nActive;
            }

            // Normalize to [-1, 1]
            let maxAbs = 0;
            for (let i = 0; i < mono.length; i++) {
                const abs = Math.abs(mono[i]);
                if (abs > maxAbs) maxAbs = abs;
            }
            if (maxAbs > 0) {
                for (let i = 0; i < mono.length; i++) {
                    mono[i] /= maxAbs;
                }
            }

            // Create audio context and buffer
            if (!audioContext) {
                audioContext = new AudioContext();
            }

            // Create buffer at 44100 Hz - this is the key trick!
            // 1000 Hz data played at 44100 Hz = 44.1x speedup
            const audioBuffer = audioContext.createBuffer(1, nSamples, 44100);
            audioBuffer.copyToChannel(mono, 0);

            // Play it
            if (audioSource) {
                audioSource.stop();
            }
            audioSource = audioContext.createBufferSource();
            audioSource.buffer = audioBuffer;
            audioSource.connect(audioContext.destination);
            audioSource.start();

            isPlaying = true;
            playBtn.textContent = 'Playing...';

            const audioDuration = nSamples / 44100;
            status.textContent = `Playing ${playDuration.toFixed(1)}s of MEG (${startSec.toFixed(1)}s-${endSec.toFixed(1)}s) as ${(audioDuration * 1000).toFixed(0)}ms audio (44.1√ó speedup)`;

            audioSource.onended = () => {
                isPlaying = false;
                playBtn.textContent = 'Play';
                status.textContent = 'Playback complete.';
            };
        }

        function stopAudio() {
            if (audioSource) {
                audioSource.stop();
                audioSource = null;
            }
            isPlaying = false;
            playBtn.textContent = 'Play';
        }

        // ===== EVENT LISTENERS =====

        loadBtn.addEventListener('click', loadRegion);
        playBtn.addEventListener('click', playAudio);
        stopBtn.addEventListener('click', stopAudio);

        // Channel selection via canvas click
        canvas.addEventListener('click', (e) => {
            if (!regionData) return;
            const rect = canvas.getBoundingClientRect();
            const clickY = (e.clientY - rect.top) * window.devicePixelRatio;
            const nChannels = regionData.n_channels;
            const height = canvas.height;
            const channelHeight = height / nChannels;
            const labelWidth = 70 * window.devicePixelRatio;
            const clickX = (e.clientX - rect.left) * window.devicePixelRatio;

            // Only respond to clicks in the label area
            if (clickX > labelWidth) return;

            const ch = Math.floor(clickY / channelHeight);
            if (ch < 0 || ch >= nChannels) return;

            if (selectedChannels.has(ch)) {
                selectedChannels.delete(ch);
            } else {
                selectedChannels.add(ch);
            }

            // Redraw to update label appearance
            const time = parseFloat(seekSlider.value);
            const startSec = Math.max(0, time - 2.5);
            drawTimeRange(startSec, 5);
        });

        // Pointer cursor over label area
        canvas.addEventListener('mousemove', (e) => {
            if (!regionData) return;
            const rect = canvas.getBoundingClientRect();
            const clickX = (e.clientX - rect.left) * window.devicePixelRatio;
            const labelWidth = 70 * window.devicePixelRatio;
            canvas.style.cursor = clickX <= labelWidth ? 'pointer' : 'default';
        });

        // Preload mode toggle
        preloadToggle.addEventListener('click', () => {
            if (preloadMode === 'auto') {
                preloadMode = 'ondemand';
                preloadToggle.textContent = 'Preload: On Demand';
                preloadToggle.style.background = '#8a5555';
            } else {
                preloadMode = 'auto';
                preloadToggle.textContent = 'Preload: Auto';
                preloadToggle.style.background = '#4a7a5a';
                // If we have region data, start prefetching
                if (regionData && !isUploadedData) {
                    fetchAllChunks();
                }
            }
        });

        // Seek slider - draw from cache (loading happens in background)
        seekSlider.addEventListener('input', async () => {
            const time = parseFloat(seekSlider.value);
            currentTimeEl.textContent = `${time.toFixed(2)}s`;

            const startSec = Math.max(0, time - 2.5);
            const endSec = Math.min(startSec + 5, regionData?.duration_seconds || 133);

            // Draw (will use cache if available, fetch if not)
            await drawTimeRange(startSec, 5);

            // Prefetch adjacent chunks (non-blocking)
            if (preloadMode === 'ondemand' && regionData && !isUploadedData) {
                const currentChunk = getChunkIndex(time);
                const totalChunks = getTotalChunks();
                // Prefetch next 2 chunks and previous 1 chunk
                for (let offset = -1; offset <= PREFETCH_AHEAD; offset++) {
                    const chunkIdx = currentChunk + offset;
                    if (chunkIdx >= 0 && chunkIdx < totalChunks && !chunkCache.has(chunkIdx) && !loadingChunks.has(chunkIdx)) {
                        fetchChunk(chunkIdx);  // Fire and forget
                    }
                }
            }
        });

        // Gain slider - redraw waveform with new amplitude
        const gainSlider = document.getElementById('gainSlider');
        const gainValueEl = document.getElementById('gainValue');
        gainSlider.addEventListener('input', () => {
            const gain = parseFloat(gainSlider.value);
            gainValueEl.textContent = gain.toFixed(2);
            // Redraw with current view
            if (regionData) {
                const time = parseFloat(seekSlider.value);
                const startSec = Math.max(0, time - 2.5);
                drawTimeRange(startSec, 5);
            }
        });

        /*
        ============================================================
        COMMENTED OUT: Browser-based .mat upload functionality

        Reason: Large files (1 hour MEG = ~4GB) exceed browser memory.
        For now, datasets are curated via scripts/export_regions.py.
        ============================================================

        // ===== TAB HANDLING =====
        const tabDemo = document.getElementById('tabDemo');
        const tabUpload = document.getElementById('tabUpload');
        const contentDemo = document.getElementById('contentDemo');
        const contentUpload = document.getElementById('contentUpload');

        tabDemo.addEventListener('click', () => {
            tabDemo.classList.add('active');
            tabUpload.classList.remove('active');
            contentDemo.classList.add('active');
            contentUpload.classList.remove('active');
        });

        tabUpload.addEventListener('click', () => {
            tabUpload.classList.add('active');
            tabDemo.classList.remove('active');
            contentUpload.classList.add('active');
            contentDemo.classList.remove('active');
            fileInput.click();
        });

        // ===== FILE UPLOAD HANDLING =====
        let uploadedMatData = null;
        let uploadedChannelNames = [];
        let uploadedSampleRate = 1000;

        const uploadStatus = document.getElementById('uploadStatus');
        const fileInput = document.getElementById('fileInput');
        const uploadControls = document.getElementById('uploadControls');
        const channelSelector = document.getElementById('channelSelector');
        const loadUploadedBtn = document.getElementById('loadUploadedBtn');

        fileInput.addEventListener('change', () => {
            if (fileInput.files.length) {
                handleMatFile(fileInput.files[0]);
            }
        });

        async function handleMatFile(file) {
            status.textContent = `Parsing ${file.name}...`;
            try {
                const arrayBuffer = await file.arrayBuffer();
                const mat = MatParser.read(arrayBuffer);
                let dataKey = Object.keys(mat).find(k =>
                    k.toLowerCase().includes('data') && !k.includes('filt')
                ) || Object.keys(mat)[0];
                const rawData = mat[dataKey];
                if (!rawData || !rawData.length) {
                    throw new Error('No data array found in .mat file');
                }
                const nChannels = rawData.length;
                const nSamples = rawData[0]?.length || 0;
                uploadedMatData = rawData;
                if (mat.ch_names) {
                    uploadedChannelNames = mat.ch_names;
                } else {
                    uploadedChannelNames = Array.from({length: nChannels}, (_, i) => `CH${i}`);
                }
                const megIndices = [];
                uploadedChannelNames.forEach((name, i) => {
                    if (typeof name === 'string' && name.startsWith('MEG')) {
                        megIndices.push(i);
                    }
                });
                channelSelector.innerHTML = '';
                uploadedChannelNames.forEach((name, i) => {
                    const isMeg = megIndices.includes(i);
                    const label = document.createElement('label');
                    label.innerHTML = `<input type="checkbox" value="${i}" ${isMeg ? 'checked' : ''}><span>${name}</span>`;
                    channelSelector.appendChild(label);
                });
                uploadControls.style.display = 'block';
                uploadStatus.innerHTML = `‚úì ${file.name} (${nChannels} ch √ó ${(nSamples/1000).toFixed(1)}s)`;
            } catch (err) {
                status.textContent = `Error parsing .mat file: ${err.message}`;
                console.error(err);
            }
        }

        function selectChannelRange(start, count) {
            const checkboxes = channelSelector.querySelectorAll('input[type="checkbox"]');
            checkboxes.forEach((cb, i) => {
                cb.checked = (i >= start && i < start + count);
            });
        }
        function selectAllChannels() {
            channelSelector.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = true);
        }
        function selectNoChannels() {
            channelSelector.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = false);
        }

        loadUploadedBtn.addEventListener('click', async () => {
            if (!uploadedMatData) return;
            const selectedIndices = [];
            const selectedNames = [];
            channelSelector.querySelectorAll('input[type="checkbox"]:checked').forEach(cb => {
                const idx = parseInt(cb.value);
                selectedIndices.push(idx);
                selectedNames.push(uploadedChannelNames[idx]);
            });
            if (selectedIndices.length === 0) {
                status.textContent = 'Please select at least one channel';
                return;
            }
            const nChannels = selectedIndices.length;
            const nSamples = uploadedMatData[0].length;
            const interleaved = new Float32Array(nSamples * nChannels);
            for (let s = 0; s < nSamples; s++) {
                for (let c = 0; c < nChannels; c++) {
                    interleaved[s * nChannels + c] = uploadedMatData[selectedIndices[c]][s];
                }
            }
            chunkCache = new Map();
            chunkCache.set(0, interleaved);
            isUploadedData = true;
            regionData = {
                description: `Uploaded (${nChannels} ch)`,
                channels: selectedNames,
                n_channels: nChannels,
                n_samples: nSamples,
                sample_rate: uploadedSampleRate,
                duration_seconds: nSamples / uploadedSampleRate,
            };
            info.innerHTML = `
                <strong>Uploaded Data</strong><br>
                Channels: ${nChannels} | Duration: ${regionData.duration_seconds.toFixed(1)}s | Sample rate: ${uploadedSampleRate} Hz
            `;
            canvas.width = canvas.offsetWidth * window.devicePixelRatio;
            canvas.height = Math.min(nChannels * 25, 900) * window.devicePixelRatio;
            canvas.style.height = `${Math.min(nChannels * 25, 900)}px`;
            seekSlider.max = regionData.duration_seconds;
            totalTimeEl.textContent = `${regionData.duration_seconds.toFixed(2)}s`;
            cacheIndicator.innerHTML = '<div style="color: #5FB3B3; font-size: 12px;">All data in memory</div>';
            await drawTimeRange(0, 5);
            playBtn.disabled = false;
            stopBtn.disabled = false;
            status.textContent = `Loaded ${nChannels} channels. Ready to explore!`;
        });
        */

        // ===== FFT & POWER SPECTRUM =====

        // Radix-2 Cooley-Tukey FFT (in-place)
        function fft(re, im) {
            const n = re.length;
            // Bit-reversal permutation
            for (let i = 1, j = 0; i < n; i++) {
                let bit = n >> 1;
                while (j & bit) { j ^= bit; bit >>= 1; }
                j ^= bit;
                if (i < j) {
                    [re[i], re[j]] = [re[j], re[i]];
                    [im[i], im[j]] = [im[j], im[i]];
                }
            }
            // FFT butterfly
            for (let len = 2; len <= n; len <<= 1) {
                const halfLen = len >> 1;
                const angle = -2 * Math.PI / len;
                const wRe = Math.cos(angle);
                const wIm = Math.sin(angle);
                for (let i = 0; i < n; i += len) {
                    let curRe = 1, curIm = 0;
                    for (let j = 0; j < halfLen; j++) {
                        const tRe = curRe * re[i + j + halfLen] - curIm * im[i + j + halfLen];
                        const tIm = curRe * im[i + j + halfLen] + curIm * re[i + j + halfLen];
                        re[i + j + halfLen] = re[i + j] - tRe;
                        im[i + j + halfLen] = im[i + j] - tIm;
                        re[i + j] += tRe;
                        im[i + j] += tIm;
                        const newCurRe = curRe * wRe - curIm * wIm;
                        curIm = curRe * wIm + curIm * wRe;
                        curRe = newCurRe;
                    }
                }
            }
        }

        // Compute power spectrum from time-interleaved data
        // Returns { freqs: Float64Array, power: Float64Array } in original MEG Hz
        function computeSpectrum(data, nChannels, sampleRate) {
            if (selectedChannels.size === 0) return null;

            const nSamples = Math.floor(data.length / nChannels);
            const activeChannels = [...selectedChannels];
            const nActive = activeChannels.length;

            // Average selected channels into mono
            const mono = new Float64Array(nSamples);
            for (let s = 0; s < nSamples; s++) {
                let sum = 0;
                for (let i = 0; i < nActive; i++) {
                    sum += data[s * nChannels + activeChannels[i]];
                }
                mono[s] = sum / nActive;
            }

            // Pad to next power of 2
            let fftSize = 1;
            while (fftSize < nSamples) fftSize <<= 1;

            // Apply Hann window and copy to FFT buffers
            const re = new Float64Array(fftSize);
            const im = new Float64Array(fftSize);
            for (let i = 0; i < nSamples; i++) {
                const window = 0.5 * (1 - Math.cos(2 * Math.PI * i / (nSamples - 1)));
                re[i] = mono[i] * window;
            }

            fft(re, im);

            // Power spectrum (magnitude squared), only positive frequencies
            const nBins = fftSize / 2;
            const power = new Float64Array(nBins);
            const freqs = new Float64Array(nBins);
            const freqRes = sampleRate / fftSize;

            for (let i = 0; i < nBins; i++) {
                freqs[i] = i * freqRes;  // Already in original MEG Hz
                power[i] = re[i] * re[i] + im[i] * im[i];
            }

            // Convert to dB
            let maxPower = 0;
            for (let i = 1; i < nBins; i++) {
                if (power[i] > maxPower) maxPower = power[i];
            }
            if (maxPower > 0) {
                for (let i = 0; i < nBins; i++) {
                    power[i] = 10 * Math.log10(power[i] / maxPower + 1e-12);
                }
            }

            return { freqs, power, nBins, freqRes };
        }

        // Cached spectrum state for hover interaction
        let lastSpectrumState = null;
        let spectrumHoverX = -1;

        // Draw power spectrum line plot
        function drawSpectrum(data, nChannels, sampleRate) {
            if (data) window._lastSpectrumArgs = [data, nChannels, sampleRate];
            const container = document.getElementById('spectrumContainer');
            const dpr = window.devicePixelRatio;
            spectrumCanvas.width = container.clientWidth * dpr;
            spectrumCanvas.height = container.clientHeight * dpr;
            spectrumCanvas.style.width = '100%';
            spectrumCanvas.style.height = '100%';

            const w = spectrumCanvas.width;
            const h = spectrumCanvas.height;
            const pad = { left: 35 * dpr, right: 10 * dpr, top: 8 * dpr, bottom: 24 * dpr };
            const plotW = w - pad.left - pad.right;
            const plotH = h - pad.top - pad.bottom;

            specCtx.fillStyle = '#0a0a1a';
            specCtx.fillRect(0, 0, w, h);

            // X range: 0 to 100 Hz (sqrt-scaled so low freqs get more room)
            const maxFreq = 100;
            const minFreq = 0.5;
            const freqToX = (f) => {
                if (f <= minFreq) return pad.left;
                return pad.left + ((Math.sqrt(f) - Math.sqrt(minFreq)) / (Math.sqrt(maxFreq) - Math.sqrt(minFreq))) * plotW;
            };
            // Y range: dB (typically -60 to 0)
            const dbMin = -60;
            const dbMax = 0;

            // Grid lines
            specCtx.strokeStyle = 'rgba(255,255,255,0.12)';
            specCtx.lineWidth = 1;
            specCtx.font = `${11 * dpr}px 'IBM Plex Mono', monospace`;
            specCtx.fillStyle = 'rgba(224,224,224,0.4)';

            // Frequency axis labels (log-spaced)
            const freqTicks = [1, 5, 10, 20, 50, 100];
            specCtx.textAlign = 'center';
            specCtx.textBaseline = 'top';
            for (const f of freqTicks) {
                if (f > maxFreq) continue;
                const x = freqToX(f);
                specCtx.beginPath();
                specCtx.moveTo(x, pad.top);
                specCtx.lineTo(x, pad.top + plotH);
                specCtx.stroke();
                specCtx.fillText(`${f}`, x, pad.top + plotH + 4 * dpr);
            }

            // dB axis labels
            specCtx.textAlign = 'right';
            specCtx.textBaseline = 'middle';
            for (let db = dbMin; db <= dbMax; db += 20) {
                const y = pad.top + ((dbMax - db) / (dbMax - dbMin)) * plotH;
                specCtx.beginPath();
                specCtx.moveTo(pad.left, y);
                specCtx.lineTo(pad.left + plotW, y);
                specCtx.stroke();
                specCtx.fillText(`${db}`, pad.left - 3 * dpr, y);
            }

            // "Hz" label
            specCtx.textAlign = 'center';
            specCtx.fillStyle = 'rgba(224,224,224,0.3)';
            specCtx.fillText('Hz', pad.left + plotW / 2, h - 7 * dpr);

            // Band markers (alpha, beta, etc.)
            const bands = [
                { name: 'Œ¥', lo: 0.5, hi: 4, color: 'rgba(224,224,224,0.5)' },
                { name: 'Œ∏', lo: 4, hi: 8, color: 'rgba(224,224,224,0.5)' },
                { name: 'Œ±', lo: 8, hi: 13, color: '#dd6666' },
                { name: 'Œ≤', lo: 13, hi: 30, color: 'rgba(224,224,224,0.5)' },
                { name: 'Œ≥', lo: 30, hi: 100, color: 'rgba(224,224,224,0.5)' },
            ];
            for (const b of bands) {
                const x1 = freqToX(b.lo);
                const x2 = freqToX(Math.min(b.hi, maxFreq));
                specCtx.fillStyle = b.color === '#dd6666' ? 'rgba(221,102,102,0.15)' : 'rgba(255,255,255,0.02)';
                specCtx.fillRect(x1, pad.top, x2 - x1, plotH);
                specCtx.fillStyle = b.color;
                specCtx.font = `bold ${12 * dpr}px 'IBM Plex Mono', monospace`;
                specCtx.textAlign = 'center';
                specCtx.textBaseline = 'top';
                specCtx.fillText(b.name, (x1 + x2) / 2, pad.top + 1 * dpr);
            }

            // Border
            specCtx.strokeStyle = 'rgba(255,255,255,0.1)';
            specCtx.lineWidth = 1;
            specCtx.strokeRect(pad.left, pad.top, plotW, plotH);

            // If no data, just show the empty axes
            if (!data || data.length === 0) return;

            const spectrum = computeSpectrum(data, nChannels, sampleRate);
            if (!spectrum) return;
            const { freqs, power, nBins } = spectrum;

            // Draw spectrum fill (area under curve)
            specCtx.beginPath();
            let started = false;
            let lastX = pad.left;

            for (let i = 1; i < nBins; i++) {
                const freq = freqs[i];
                if (freq > maxFreq) break;
                if (freq < 0.3) continue;
                const x = freqToX(freq);
                const db = Math.max(dbMin, Math.min(dbMax, power[i]));
                const y = pad.top + ((dbMax - db) / (dbMax - dbMin)) * plotH;

                if (!started) { specCtx.moveTo(x, pad.top + plotH); specCtx.lineTo(x, y); started = true; }
                else specCtx.lineTo(x, y);
                lastX = x;
            }
            specCtx.lineTo(lastX, pad.top + plotH);
            specCtx.closePath();
            const fillGrad = specCtx.createLinearGradient(0, pad.top, 0, pad.top + plotH);
            fillGrad.addColorStop(0, 'rgba(95,179,179,0.25)');
            fillGrad.addColorStop(1, 'rgba(95,179,179,0.02)');
            specCtx.fillStyle = fillGrad;
            specCtx.fill();

            // Draw spectrum line
            specCtx.strokeStyle = '#5FB3B3';
            specCtx.lineWidth = 1.5 * dpr;
            specCtx.beginPath();
            started = false;

            for (let i = 1; i < nBins; i++) {
                const freq = freqs[i];
                if (freq > maxFreq) break;
                if (freq < 0.3) continue;
                const x = freqToX(freq);
                const db = Math.max(dbMin, Math.min(dbMax, power[i]));
                const y = pad.top + ((dbMax - db) / (dbMax - dbMin)) * plotH;

                if (!started) { specCtx.moveTo(x, y); started = true; }
                else specCtx.lineTo(x, y);
            }
            specCtx.stroke();

            // Cache state for hover
            lastSpectrumState = { freqs, power, nBins, pad, plotW, plotH, w, h, dpr, dbMin, dbMax, maxFreq, minFreq, freqToX };

            // Draw hover overlay if active
            if (spectrumHoverX >= 0) drawSpectrumHover(spectrumHoverVisible);
        }

        function drawSpectrumHover(showLabel) {
            const s = lastSpectrumState;
            if (!s || spectrumHoverX < 0) return;
            const { freqs, power, nBins, pad, plotW, plotH, dpr, dbMin, dbMax, maxFreq, minFreq, freqToX } = s;

            // Convert CSS mouse X to canvas X
            const cx = spectrumHoverX * dpr;
            if (cx < pad.left || cx > pad.left + plotW) return;

            // Reverse freqToX: cx = pad.left + ((sqrt(f) - sqrt(minFreq)) / (sqrt(maxFreq) - sqrt(minFreq))) * plotW
            const ratio = (cx - pad.left) / plotW;
            const sqrtF = Math.sqrt(minFreq) + ratio * (Math.sqrt(maxFreq) - Math.sqrt(minFreq));
            const hoverFreq = sqrtF * sqrtF;

            // Find closest bin
            let closestBin = 1;
            let closestDist = Infinity;
            for (let i = 1; i < nBins; i++) {
                if (freqs[i] > maxFreq) break;
                const d = Math.abs(freqs[i] - hoverFreq);
                if (d < closestDist) { closestDist = d; closestBin = i; }
            }

            const freq = freqs[closestBin];
            const db = Math.max(dbMin, Math.min(dbMax, power[closestBin]));
            const lineX = freqToX(freq);
            const lineY = pad.top + ((dbMax - db) / (dbMax - dbMin)) * plotH;

            // Vertical crosshair line (always shown)
            specCtx.strokeStyle = 'rgba(255,255,255,0.2)';
            specCtx.lineWidth = 1;
            specCtx.beginPath();
            specCtx.moveTo(lineX, pad.top);
            specCtx.lineTo(lineX, pad.top + plotH);
            specCtx.stroke();

            // Dot on the line (always shown)
            specCtx.fillStyle = '#5FB3B3';
            specCtx.beginPath();
            specCtx.arc(lineX, lineY, 3 * dpr, 0, Math.PI * 2);
            specCtx.fill();

            // Label only shown after pause, with fade-in opacity
            if (!showLabel) return;
            const opacity = spectrumLabelOpacity;

            const label = `${freq.toFixed(1)} Hz  ${db.toFixed(1)} dB`;
            specCtx.font = `bold ${11 * dpr}px 'IBM Plex Mono', monospace`;
            const textW = specCtx.measureText(label).width;

            // Position above the line, or below if too close to top
            const aboveY = lineY - 8 * dpr;
            const belowY = lineY + 14 * dpr;
            const textY = aboveY > pad.top + 14 * dpr ? aboveY : belowY;

            // Center on lineX, but clamp to plot area
            let textX = lineX;
            const halfW = textW / 2 + 4 * dpr;
            if (textX - halfW < pad.left) textX = pad.left + halfW;
            if (textX + halfW > pad.left + plotW) textX = pad.left + plotW - halfW;

            // Background pill
            specCtx.fillStyle = `rgba(10,10,26,${0.55 * opacity})`;
            specCtx.beginPath();
            const pillX = textX - textW / 2 - 4 * dpr;
            const pillY = textY - 8 * dpr;
            const pillW = textW + 8 * dpr;
            const pillH = 12 * dpr;
            specCtx.roundRect(pillX, pillY, pillW, pillH, 3 * dpr);
            specCtx.fill();

            // Text
            specCtx.fillStyle = `rgba(95,179,179,${opacity})`;
            specCtx.textAlign = 'center';
            specCtx.textBaseline = 'middle';
            specCtx.fillText(label, textX, textY - 2 * dpr);
        }

        // Spectrum hover events: crosshair immediate, label after 200ms pause with fade-in
        let spectrumHoverTimer = null;
        let spectrumHoverVisible = false;
        let spectrumLabelOpacity = 0;
        let spectrumFadeAnim = null;

        function startLabelFade() {
            spectrumHoverVisible = true;
            spectrumLabelOpacity = 0;
            const startTime = performance.now();
            const fadeDuration = 200;
            function fadeStep(now) {
                spectrumLabelOpacity = Math.min(1, (now - startTime) / fadeDuration);
                if (window._lastSpectrumArgs) drawSpectrum(...window._lastSpectrumArgs);
                if (spectrumLabelOpacity < 1 && spectrumHoverVisible) {
                    spectrumFadeAnim = requestAnimationFrame(fadeStep);
                } else {
                    spectrumFadeAnim = null;
                }
            }
            spectrumFadeAnim = requestAnimationFrame(fadeStep);
        }

        spectrumCanvas.addEventListener('mousemove', (e) => {
            const rect = spectrumCanvas.getBoundingClientRect();
            const newX = e.clientX - rect.left;

            // Always update crosshair position immediately
            spectrumHoverX = newX;

            if (spectrumHoverVisible) {
                // Label already showing, just redraw
                if (window._lastSpectrumArgs) drawSpectrum(...window._lastSpectrumArgs);
                return;
            }

            // Reset timer for label appearance
            if (spectrumHoverTimer) clearTimeout(spectrumHoverTimer);
            spectrumHoverTimer = setTimeout(() => {
                startLabelFade();
            }, 200);

            // Redraw with crosshair only (no label yet)
            if (window._lastSpectrumArgs) drawSpectrum(...window._lastSpectrumArgs);
        });

        spectrumCanvas.addEventListener('mouseleave', () => {
            if (spectrumHoverTimer) clearTimeout(spectrumHoverTimer);
            spectrumHoverTimer = null;
            if (spectrumFadeAnim) cancelAnimationFrame(spectrumFadeAnim);
            spectrumFadeAnim = null;
            spectrumHoverX = -1;
            spectrumHoverVisible = false;
            spectrumLabelOpacity = 0;
            if (window._lastSpectrumArgs) drawSpectrum(...window._lastSpectrumArgs);
        });

        // Draw empty spectrum axes on load
        drawSpectrum(null, 0, 0);

        // Start
        init();
    </script>
</body>
</html>
