<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MEG Audification</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üß≤</text></svg>">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=IBM+Plex+Mono:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        :root { --page-bg: #1a1a2e; --box-radius: 8px; }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--page-bg);
            color: #e0e0e0;
            padding: 24px;
        }
        h1 {
            margin-bottom: 24px;
            background: linear-gradient(135deg, #667eea 0%, #9b6bc9 50%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            font-weight: 700;
            font-size: 24px;
            letter-spacing: -0.5px;
        }
        .controls {
            display: flex;
            gap: 16px;
            margin-bottom: 16px;
            flex-wrap: wrap;
            align-items: center;
        }
        select, button {
            padding: 8px 16px;
            font-size: 14px;
            font-family: 'Inter', sans-serif;
            font-weight: 500;
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.15s ease;
        }
        select {
            background: #2a2a4a;
            color: #e0e0e0;
        }
        select:hover { border-color: rgba(255,255,255,0.2); }
        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #ffffff;
            font-weight: 600;
            box-shadow: 0 3px 6px rgba(0,0,0,0.25), inset 0 1px 0 rgba(255,255,255,0.15);
            text-shadow: 0 1px 2px rgba(0,0,0,0.2);
            height: 38px;
            line-height: 20px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            border: 1px solid rgba(102,126,234,0.3);
        }
        button:hover:not(:disabled) {
            transform: translateY(-1px);
            box-shadow: 0 5px 12px rgba(102,126,234,0.4), inset 0 1px 0 rgba(255,255,255,0.15);
            background: linear-gradient(135deg, #7a8ef0 0%, #8a5fb5 100%);
        }
        button:active:not(:disabled) {
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.4);
            transform: translateY(1px);
        }
        button:disabled {
            background: #3a3a4a;
            color: #666;
            cursor: not-allowed;
            box-shadow: none;
            border-color: rgba(255,255,255,0.05);
        }
        #playPauseBtn {
            width: 135px;
            min-width: 135px;
        }
        #loopBtn {
            width: 135px;
            min-width: 135px;
        }
        #loopBtn:not(.loop-active) {
            background: linear-gradient(135deg, #6b5a7a 0%, #4a3d5a 100%);
        }
        #loopBtn:not(.loop-active):hover:not(:disabled) {
            background: linear-gradient(135deg, #7b6a8a 0%, #5a4d6a 100%);
        }
        #loopBtn.loop-active {
            background: linear-gradient(135deg, #9b6bc9 0%, #7a4ba9 100%);
            box-shadow: 0 0 8px rgba(155,107,201,0.4);
        }
        #loopBtn.loop-active:hover:not(:disabled) {
            background: linear-gradient(135deg, #ab7bd9 0%, #8a5bb9 100%);
            box-shadow: 0 0 12px rgba(155,107,201,0.5);
        }
        .play-active {
            background: linear-gradient(135deg, #4a9b6a 0%, #2d7048 100%) !important;
        }
        .play-active:hover:not(:disabled) {
            background: linear-gradient(135deg, #5aab7a 0%, #3d8058 100%) !important;
        }
        @keyframes pulse-glow {
            0%, 100% { box-shadow: 0 3px 6px rgba(0,0,0,0.25); background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); }
            50% { box-shadow: 0 0 18px rgba(102,126,234,0.7); background: linear-gradient(135deg, #7a8ef0 0%, #8a5fb5 100%); }
        }
        .pulse { animation: pulse-glow 1.5s ease-in-out infinite; }
        .info {
            background: #2a2a4a;
            padding: 16px;
            border-radius: var(--box-radius);
            border: 1px solid rgba(255,255,255,0.1);
            font-family: 'IBM Plex Mono', monospace;
            font-size: 12px;
            color: rgba(224,224,224,0.7);
            min-height: 80px;
            max-height: 80px;
            margin-bottom: 0;
        }
        .info strong {
            color: #e0e0e0;
            font-weight: 600;
        }
        .data-display {
            display: flex;
            gap: 16px;
            margin-bottom: 24px;
        }
        .sensor-map {
            flex-shrink: 0;
            width: 715px;
            aspect-ratio: 1056 / 992;
            background: #0a0a1a;
            border-radius: var(--box-radius);
            border: 1px solid rgba(255,255,255,0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 8px;
        }
        .sensor-map img {
            width: 100%;
            height: auto;
            border-radius: 2px;
        }
        .waveform-panel {
            border-radius: var(--box-radius);
            border: 1px solid rgba(255,255,255,0.1);
            overflow: hidden;
            background: #0a0a1a;
        }
        #waveformContainer {
            background: #0a0a1a;
        }
        canvas { display: block; width: 100%; }
        input[type="range"] { opacity: 0.5; }
        #spectrumContainer { cursor: default; }
        .time-indicator {
            display: flex;
            justify-content: space-between;
            padding: 8px 16px;
            background: #2a2a4a;
            font-family: 'IBM Plex Mono', monospace;
            font-size: 12px;
            color: rgba(224,224,224,0.7);
        }
        .status {
            padding: 8px 16px;
            background: #2a2a4a;
            border-radius: 4px;
            margin-bottom: 16px;
        }

        /* Upload section */
        .channel-selector {
            max-height: 200px;
            overflow-y: auto;
            background: #2a2a4a;
            padding: 8px;
            border-radius: 4px;
            margin-bottom: 8px;
        }
        .channel-selector label {
            display: inline-block;
            padding: 2px 8px;
            margin: 2px;
            background: #3a3a5a;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
        }
        .channel-selector input:checked + span {
            color: #5FB3B3;
        }
        .quick-select {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-bottom: 8px;
        }
        .quick-select button {
            padding: 4px 8px;
            font-size: 12px;
            background: #3a3a5a;
        }

        /* Tabs - commented out, see upload code below
        .tabs { display: flex; gap: 4px; margin-bottom: 16px; }
        .tab { padding: 8px 16px; background: #2a2a4a; border: 1px solid rgba(255,255,255,0.1); border-radius: 4px 4px 0 0; color: #888; cursor: pointer; font-size: 14px; transition: all 0.15s; }
        .tab:hover { background: #3a3a5a; color: #ccc; }
        .tab.active { background: #5FB3B3; color: #1a1a2e; font-weight: bold; }
        .tab-content { display: none; padding: 16px; background: #2a2a4a; border-radius: 0 4px 4px 4px; margin-bottom: 16px; }
        .tab-content.active { display: block; }
        */
    </style>
</head>
<body>
    <h1>MEG Audification Explorer</h1>

    <!-- Region selector (demo data) -->
    <div class="controls">
        <select id="regionSelect">
            <option value="">Loading regions...</option>
        </select>
        <button id="loadBtn" disabled>Load Region</button>
        <button id="playPauseBtn" disabled>‚ñ∂Ô∏è Play</button>
        <button id="loopBtn" disabled>üîÅ Loop</button>
        <span style="color: rgba(255,255,255,0.15); margin: 0 8px;">|</span>
        <button id="preloadToggle" style="background: #4a7a5a; font-size: 12px; width: 160px; text-align: center;">Preload: Auto</button>
        <span id="cacheStatus" style="color: rgba(224,224,224,0.5); font-size: 12px; font-family: 'IBM Plex Mono', monospace; margin-left: 8px;"></span>
    </div>

    <!--
    ============================================================
    COMMENTED OUT: Browser-based .mat upload

    Reason: Large files (1 hour MEG = ~4GB) exceed browser memory.
    For now, datasets are curated via scripts/export_regions.py.
    This code is preserved for potential future use with smaller files
    or if we add server-side processing.
    ============================================================

    <div class="tabs">
        <button class="tab active" id="tabDemo">Demo Data</button>
        <button class="tab" id="tabUpload">Upload .mat File</button>
        <input type="file" id="fileInput" accept=".mat" style="display: none;">
    </div>

    <div class="tab-content active" id="contentDemo">
        <div class="controls">
            <select id="regionSelect">
                <option value="">Loading regions...</option>
            </select>
            <button id="loadBtn" disabled>Load Region</button>
        </div>
    </div>

    <div class="tab-content" id="contentUpload">
        <div style="margin-bottom: 10px;">
            <span id="uploadStatus" style="color: #888;">Click the tab above to select a .mat file</span>
        </div>
        <div id="uploadControls" style="display: none;">
            <div class="quick-select">
                <span style="color: #888;">Quick select:</span>
                <button onclick="selectChannelRange(0, 50)">First 50</button>
                <button onclick="selectChannelRange(0, 100)">First 100</button>
                <button onclick="selectAllChannels()">All MEG</button>
                <button onclick="selectNoChannels()">Clear</button>
            </div>
            <div class="channel-selector" id="channelSelector"></div>
            <button id="loadUploadedBtn">Load Selected Channels</button>
        </div>
    </div>
    -->

    <div id="status" style="display:none;"></div>
    <div style="display: flex; gap: 16px; margin-bottom: 16px;">
        <div class="info" id="info" style="flex-shrink: 0; width: 715px;">
                <strong>No Region Loaded</strong><br>
                Channels: 0 | Duration: 0s | Sample rate: N/A<br>
                <span style="color: #5FB3B3;">Chunk size: N/A | 0 total chunks</span>
        </div>
        <div id="spectrumContainer" style="flex: 1; background: #0a0a1a; border-radius: var(--box-radius); border: 1px solid rgba(255,255,255,0.1); min-height: 100px; max-height: 100px; min-width: 0; overflow: hidden;">
            <canvas id="spectrum"></canvas>
        </div>
    </div>

    <div class="data-display">
        <div class="sensor-map">
            <img id="sensorImg" src="sensor_layout.jpeg" alt="Neuromag MEG sensor layout">
        </div>
        <div style="flex: 1; min-width: 0; display: flex; flex-direction: column; gap: 0;">
            <div class="waveform-panel">
                <div id="minimapContainer" style="background: #0a0a1a; height: 55px; cursor: pointer; position: relative;">
                    <canvas id="minimap" style="display: block; width: 100%; height: 100%;"></canvas>
                </div>
                <div id="waveformContainer">
                    <canvas id="waveform"></canvas>
                </div>
            </div>
        </div>
    </div>
    <div style="display: flex; gap: 16px; margin-top: -16px; margin-bottom: 24px;">
        <div style="flex-shrink: 0; width: 715px;"></div>
        <div style="display: flex; align-items: center; gap: 8px;">
            <span style="color: rgba(224,224,224,0.5); font-size: 12px; font-family: 'IBM Plex Mono', monospace; white-space: nowrap;">Gain: <span id="gainValue">2.00</span>√ó</span>
            <input type="range" id="gainSlider" min="1" max="5" value="2" step="0.01"
                   style="flex: 1; max-width: 300px;">
        </div>
        <!-- Filter controls now live on the spectrum plot -->
    </div>

    <script>
        /*
        ============================================================
        COMMENTED OUT: MAT v5 Parser for browser-based upload

        Reason: Large files exceed browser memory. See upload code below.
        ============================================================

        const MatParser = {
            TYPES: { 1: 'int8', 2: 'uint8', 3: 'int16', 4: 'uint16', 5: 'int32', 6: 'uint32', 7: 'float32', 9: 'float64', 12: 'int64', 13: 'uint64', 14: 'matrix', 15: 'compressed', 16: 'utf8', 17: 'utf16', 18: 'utf32' },
            read(arrayBuffer) { ... },
            readElement(view, offset) { ... },
            readMatrix(view, offset, totalSize, nextOffset) { ... },
            skipSubelement(view, offset) { ... },
            readDimensions(view, offset) { ... },
            readName(view, offset) { ... },
            readNumericData(view, offset, dimensions) { ... },
            transpose(arr) { ... }
        };
        */

        // ===== CONFIGURATION =====
        const DATA_BASE_URL = 'data/processed/regions';
        const CHUNK_DURATION = 5;  // seconds per chunk
        const PREFETCH_AHEAD = 2;   // prefetch this many chunks ahead
        const PAGE_BG = getComputedStyle(document.documentElement).getPropertyValue('--page-bg').trim();

        // ===== STATE =====
        let metadata = null;
        let regionData = null;
        let audioContext = null;
        let audioSource = null;
        let gainNode = null;
        const FADE_MS = 25;
        let isPlaying = false;
        let playStartTime = 0;
        let playStartOffset = 0;

        // Chunk cache: Map<chunkIndex, Float32Array>
        let chunkCache = new Map();
        let loadingChunks = new Set();  // Currently fetching
        let isUploadedData = false;  // True when using uploaded .mat file
        let preloadMode = 'auto';  // 'auto' = prefetch all, 'ondemand' = fetch only when needed
        let selectedChannels = new Set();  // Channels selected for audification

        // High-pass filter state
        let highPassEnabled = false;
        let highPassFreq = 1.0;  // Hz
        let highPassFilterNode = null;  // Web Audio BiquadFilterNode for audio playback

        // Low-pass filter state
        let lowPassEnabled = false;
        let lowPassFreq = 40.0;  // Hz
        let lowPassFilterNode = null;

        // Scrub audio (Paul stretch) state
        let scrubWorkletNode = null;
        let scrubGainNode = null;
        let scrubHPFilter = null;
        let scrubLPFilter = null;
        let scrubMonoBuffer = null;   // Normalized mono Float32Array for worklet
        let scrubWorkletReady = false;

        // Playhead & minimap state
        let playStartWallTime = 0;      // AudioContext.currentTime when playback started
        let playStartDataOffset = 0;    // MEG-time (seconds) where playback began
        let animationFrameId = null;    // rAF handle for animation loop
        const VIEW_WINDOW = 10;         // seconds of MEG data visible in main waveform
        let currentPlayheadTime = null; // current MEG-time position of playhead (null = not set)
        let currentViewStart = 0;       // left edge of main waveform view (seconds)

        // Minimap offscreen cache ‚Äî waveform data is expensive to redraw
        let minimapCacheCanvas = null;
        let minimapCacheDirty = true;   // true = waveforms need redraw

        // ===== DOM ELEMENTS =====
        const regionSelect = document.getElementById('regionSelect');
        const loadBtn = document.getElementById('loadBtn');
        const playPauseBtn = document.getElementById('playPauseBtn');
        const loopBtn = document.getElementById('loopBtn');
        let isLooping = false;
        const status = document.getElementById('status');
        const info = document.getElementById('info');
        const canvas = document.getElementById('waveform');
        const ctx = canvas.getContext('2d');
        const minimapCanvas = document.getElementById('minimap');
        const minimapCtx = minimapCanvas.getContext('2d');
        const preloadToggle = document.getElementById('preloadToggle');
        const spectrumCanvas = document.getElementById('spectrum');
        const specCtx = spectrumCanvas.getContext('2d');
        // Filter handle interaction state (for spectrum plot handles)
        let filterDragging = null;  // 'hp' or 'lp' or null
        let filterClickStart = null;  // {x, time} to distinguish click from drag

        // ===== FILTERS (zero-allocation biquad for animation loop) =====
        // Pre-allocated reusable buffers to avoid GC pressure during 60fps playback
        let _filterBufA = null;
        let _filterBufB = null;

        function _ensureFilterBuf(buf, size) {
            return (buf && buf.length >= size) ? buf : new Float32Array(size);
        }

        // Core biquad: writes into pre-allocated output buffer (no allocation)
        function _biquad(data, out, nChannels, sampleRate, cutoffHz, type) {
            const nSamples = Math.floor(data.length / nChannels);
            const w0 = 2 * Math.PI * cutoffHz / sampleRate;
            const cosw0 = Math.cos(w0);
            const alpha = Math.sin(w0) / (2 * Math.SQRT2);

            let b0, b1, b2;
            if (type === 'highpass') {
                b0 = (1 + cosw0) / 2;
                b1 = -(1 + cosw0);
                b2 = (1 + cosw0) / 2;
            } else {
                b0 = (1 - cosw0) / 2;
                b1 = (1 - cosw0);
                b2 = (1 - cosw0) / 2;
            }
            const a0 = 1 + alpha;
            const a1 = -2 * cosw0;
            const a2 = 1 - alpha;

            const nb0 = b0 / a0, nb1 = b1 / a0, nb2 = b2 / a0;
            const na1 = a1 / a0, na2 = a2 / a0;

            for (let ch = 0; ch < nChannels; ch++) {
                let x1 = 0, x2 = 0, y1 = 0, y2 = 0;
                for (let s = 0; s < nSamples; s++) {
                    const idx = s * nChannels + ch;
                    const x0 = data[idx];
                    const y0 = nb0 * x0 + nb1 * x1 + nb2 * x2 - na1 * y1 - na2 * y2;
                    out[idx] = y0;
                    x2 = x1; x1 = x0;
                    y2 = y1; y1 = y0;
                }
            }
        }

        // Zero-allocation filter path for animation loop
        // Returns a buffer containing filtered data (may be input data if no filters active)
        function applyFilters(data, nChannels, sampleRate) {
            if (!data || data.length === 0) return data;
            if (!highPassEnabled && !lowPassEnabled) return data;

            const len = data.length;
            _filterBufA = _ensureFilterBuf(_filterBufA, len);
            _filterBufB = _ensureFilterBuf(_filterBufB, len);

            if (highPassEnabled && lowPassEnabled) {
                _biquad(data, _filterBufA, nChannels, sampleRate, highPassFreq, 'highpass');
                _biquad(_filterBufA, _filterBufB, nChannels, sampleRate, lowPassFreq, 'lowpass');
                return _filterBufB;
            } else if (highPassEnabled) {
                _biquad(data, _filterBufA, nChannels, sampleRate, highPassFreq, 'highpass');
                return _filterBufA;
            } else {
                _biquad(data, _filterBufA, nChannels, sampleRate, lowPassFreq, 'lowpass');
                return _filterBufA;
            }
        }

        // Legacy allocating versions kept for non-animation code (minimap cache, static draws)
        function applyHighPass(data, nChannels, sampleRate, cutoffHz) {
            if (!data || data.length === 0) return data;
            const out = new Float32Array(data.length);
            _biquad(data, out, nChannels, sampleRate, cutoffHz, 'highpass');
            return out;
        }

        function maybeHighPass(data, nChannels, sampleRate) {
            if (!highPassEnabled || !data) return data;
            return applyHighPass(data, nChannels, sampleRate, highPassFreq);
        }

        function applyLowPass(data, nChannels, sampleRate, cutoffHz) {
            if (!data || data.length === 0) return data;
            const out = new Float32Array(data.length);
            _biquad(data, out, nChannels, sampleRate, cutoffHz, 'lowpass');
            return out;
        }

        function maybeLowPass(data, nChannels, sampleRate) {
            if (!lowPassEnabled || !data) return data;
            return applyLowPass(data, nChannels, sampleRate, lowPassFreq);
        }

        // ===== CHUNK MANAGEMENT =====

        function getChunkIndex(timeSec) {
            return Math.floor(timeSec / CHUNK_DURATION);
        }

        function getChunkTimeRange(chunkIndex) {
            const start = chunkIndex * CHUNK_DURATION;
            const end = Math.min(start + CHUNK_DURATION, regionData?.duration_seconds || 133);
            return { start, end };
        }

        function getTotalChunks() {
            if (!regionData) return 0;
            return Math.ceil(regionData.duration_seconds / CHUNK_DURATION);
        }

        // Fetch a single chunk by index
        async function fetchChunk(chunkIndex) {
            if (!regionData) return null;
            if (chunkCache.has(chunkIndex)) return chunkCache.get(chunkIndex);
            if (loadingChunks.has(chunkIndex)) return null;  // Already loading

            const { start, end } = getChunkTimeRange(chunkIndex);
            if (start >= regionData.duration_seconds) return null;

            loadingChunks.add(chunkIndex);
            updateCacheIndicator();

            const bytesPerSample = regionData.n_channels * 4;
            const samplesPerSec = regionData.sample_rate;
            const startByte = Math.floor(start * samplesPerSec * bytesPerSample);
            const endByte = Math.floor(end * samplesPerSec * bytesPerSample);

            // console.log(`üì¶ Fetching chunk ${chunkIndex} (${start}s-${end}s): bytes ${startByte}-${endByte}`);

            try {
                const response = await fetch(`${DATA_BASE_URL}/${regionData.file}`, {
                    headers: { 'Range': `bytes=${startByte}-${endByte - 1}` }
                });

                if (response.status === 206) {
                    // console.log(`‚úÖ Chunk ${chunkIndex}: 206 Partial Content`);
                } else {
                    console.warn(`‚ö†Ô∏è Chunk ${chunkIndex}: ${response.status} (Range not supported?)`);
                }

                const buffer = await response.arrayBuffer();
                const data = new Float32Array(buffer);

                chunkCache.set(chunkIndex, data);
                loadingChunks.delete(chunkIndex);
                updateCacheIndicator();

                return data;
            } catch (err) {
                console.error(`‚ùå Chunk ${chunkIndex} failed:`, err);
                loadingChunks.delete(chunkIndex);
                updateCacheIndicator();
                return null;
            }
        }

        // Fetch ALL chunks sequentially in background
        async function fetchAllChunks() {
            const totalChunks = getTotalChunks();
            for (let i = 0; i < totalChunks; i++) {
                if (!chunkCache.has(i) && !loadingChunks.has(i)) {
                    await fetchChunk(i);
                }
            }
            document.getElementById('cacheStatus').textContent = `All ${totalChunks} chunks loaded!`;
            drawMinimap(); // Redraw minimap with all data
            updateScrubBuffer(); // Refresh scrub audio with complete data
        }

        // Get data for a time range (from cache or fetch)
        async function getDataForTimeRange(startSec, endSec) {
            // For uploaded data, all data is in chunk 0
            if (isUploadedData) {
                const fullData = chunkCache.get(0);
                if (!fullData) return null;
                const offsetStart = Math.floor(startSec * regionData.sample_rate) * regionData.n_channels;
                const offsetEnd = Math.floor(endSec * regionData.sample_rate) * regionData.n_channels;
                return fullData.slice(offsetStart, Math.min(offsetEnd, fullData.length));
            }

            const startChunk = getChunkIndex(startSec);
            const endChunk = getChunkIndex(endSec - 0.001);  // Avoid edge case

            // Collect all needed chunks
            const chunks = [];
            for (let i = startChunk; i <= endChunk; i++) {
                let data = chunkCache.get(i);
                if (!data) {
                    data = await fetchChunk(i);
                }
                if (data) chunks.push({ index: i, data });
            }

            if (chunks.length === 0) return null;

            // If single chunk, slice to exact range
            if (chunks.length === 1) {
                const chunk = chunks[0];
                const chunkStart = chunk.index * CHUNK_DURATION;
                const offsetStart = Math.floor((startSec - chunkStart) * regionData.sample_rate) * regionData.n_channels;
                const offsetEnd = Math.floor((endSec - chunkStart) * regionData.sample_rate) * regionData.n_channels;
                return chunk.data.slice(offsetStart, Math.min(offsetEnd, chunk.data.length));
            }

            // Multiple chunks - concatenate
            // First, calculate actual total size by summing slices
            let totalSize = 0;
            const slices = [];

            for (const chunk of chunks) {
                const chunkStart = chunk.index * CHUNK_DURATION;
                const chunkEnd = Math.min(chunkStart + CHUNK_DURATION, regionData.duration_seconds);

                const sliceStart = Math.max(startSec, chunkStart);
                const sliceEnd = Math.min(endSec, chunkEnd);

                const offsetStart = Math.floor((sliceStart - chunkStart) * regionData.sample_rate) * regionData.n_channels;
                const offsetEnd = Math.floor((sliceEnd - chunkStart) * regionData.sample_rate) * regionData.n_channels;

                const slice = chunk.data.slice(offsetStart, Math.min(offsetEnd, chunk.data.length));
                slices.push(slice);
                totalSize += slice.length;
            }

            // Now allocate and copy
            const result = new Float32Array(totalSize);
            let writeOffset = 0;
            for (const slice of slices) {
                result.set(slice, writeOffset);
                writeOffset += slice.length;
            }

            return result;
        }

        // Synchronous cache lookup - returns data if all chunks are cached, null otherwise
        // Reusable buffer for multi-chunk assembly (avoids per-frame allocation)
        let _cacheSyncBuf = null;

        function getDataFromCacheSync(startSec, endSec) {
            if (!regionData) return null;
            if (isUploadedData) {
                const fullData = chunkCache.get(0);
                if (!fullData) return null;
                const offsetStart = Math.floor(startSec * regionData.sample_rate) * regionData.n_channels;
                const offsetEnd = Math.floor(endSec * regionData.sample_rate) * regionData.n_channels;
                return fullData.subarray(offsetStart, Math.min(offsetEnd, fullData.length));
            }

            const startChunk = getChunkIndex(startSec);
            const endChunk = getChunkIndex(Math.max(0, endSec - 0.001));

            // Check all chunks present
            for (let i = startChunk; i <= endChunk; i++) {
                if (!chunkCache.has(i)) return null;
            }

            if (startChunk === endChunk) {
                // Single chunk: return a zero-copy subarray view
                const data = chunkCache.get(startChunk);
                const chunkStart = startChunk * CHUNK_DURATION;
                const offsetStart = Math.floor((startSec - chunkStart) * regionData.sample_rate) * regionData.n_channels;
                const offsetEnd = Math.floor((endSec - chunkStart) * regionData.sample_rate) * regionData.n_channels;
                return data.subarray(offsetStart, Math.min(offsetEnd, data.length));
            }

            // Multi-chunk: assemble into reusable buffer
            let totalSize = 0;
            for (let i = startChunk; i <= endChunk; i++) {
                const chunkStart = i * CHUNK_DURATION;
                const chunkEnd = Math.min(chunkStart + CHUNK_DURATION, regionData.duration_seconds);
                const sliceStart = Math.max(startSec, chunkStart);
                const sliceEnd = Math.min(endSec, chunkEnd);
                totalSize += Math.floor((sliceEnd - sliceStart) * regionData.sample_rate) * regionData.n_channels;
            }

            if (!_cacheSyncBuf || _cacheSyncBuf.length < totalSize) {
                _cacheSyncBuf = new Float32Array(totalSize);
            }

            let writeOffset = 0;
            for (let i = startChunk; i <= endChunk; i++) {
                const data = chunkCache.get(i);
                const chunkStart = i * CHUNK_DURATION;
                const chunkEnd = Math.min(chunkStart + CHUNK_DURATION, regionData.duration_seconds);
                const sliceStart = Math.max(startSec, chunkStart);
                const sliceEnd = Math.min(endSec, chunkEnd);
                const offsetStart = Math.floor((sliceStart - chunkStart) * regionData.sample_rate) * regionData.n_channels;
                const offsetEnd = Math.floor((sliceEnd - chunkStart) * regionData.sample_rate) * regionData.n_channels;
                const src = data.subarray(offsetStart, Math.min(offsetEnd, data.length));
                _cacheSyncBuf.set(src, writeOffset);
                writeOffset += src.length;
            }
            return _cacheSyncBuf.subarray(0, writeOffset);
        }

        // Update cache indicator (new chunk loaded ‚Äî invalidate minimap cache)
        function updateCacheIndicator() {
            minimapCacheDirty = true;
            drawMinimap();
        }

        // ===== INITIALIZATION =====

        async function init() {
            try {
                const response = await fetch(`${DATA_BASE_URL}/metadata.json`);
                metadata = await response.json();

                regionSelect.innerHTML = '<option value="">Select a region...</option>';
                for (const [key, region] of Object.entries(metadata.regions)) {
                    const opt = document.createElement('option');
                    opt.value = key;
                    opt.textContent = `${region.description} (${region.n_channels} ch)`;
                    regionSelect.appendChild(opt);
                }

                // Default to left occipital
                if (metadata.regions['left_occipital']) {
                    regionSelect.value = 'left_occipital';
                }

                // Enter key triggers load
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' && regionSelect.value && !loadBtn.disabled) {
                        loadRegion();
                    }
                });

                loadBtn.disabled = false;
                loadBtn.classList.add('pulse');
                document.getElementById('cacheStatus').textContent = 'Ready. Press Enter or click Load.';
            } catch (err) {
                document.getElementById('cacheStatus').textContent = `Error: ${err.message}`;
                console.error(err);
            }
        }

        // ===== LOAD REGION =====

        async function loadRegion() {
            loadBtn.classList.remove('pulse');
            const regionKey = regionSelect.value;
            if (!regionKey) return;

            const region = metadata.regions[regionKey];
            status.textContent = `Loading ${region.description}...`;
            loadBtn.disabled = true;

            // Reset cache
            chunkCache = new Map();
            loadingChunks = new Set();
            isUploadedData = false;
            minimapCacheDirty = true;

            regionData = { ...region };
            _buildChannelCache(regionData.n_channels);

            // Update sensor map image based on region
            const sensorImg = document.getElementById('sensorImg');
            sensorImg.src = regionKey === 'left_occipital'
                ? 'Neuromag_MEG_sensor_layout_Black_L_Occipital_Highlight.jpg'
                : 'sensor_layout.jpeg';

            // Default-select MEG1732 if present in this region
            selectedChannels = new Set();
            if (region.channels) {
                const idx = region.channels.indexOf('MEG1732');
                if (idx !== -1) selectedChannels.add(idx);
            }

            const totalChunks = getTotalChunks();
            const bytesPerChunk = CHUNK_DURATION * region.sample_rate * region.n_channels * 4;

            info.innerHTML = `
                <strong>${region.description}</strong><br>
                Channels: ${region.n_channels} | Duration: ${region.duration_seconds}s | Sample rate: ${region.sample_rate} Hz<br>
                <span style="color: #5FB3B3;">Chunk size: ${CHUNK_DURATION}s (${(bytesPerChunk/1024).toFixed(0)} KB) | ${totalChunks} total chunks</span>
            `;

            // Setup canvas
            canvas.width = canvas.offsetWidth * window.devicePixelRatio;
            const canvasH = Math.min(region.n_channels * 26.5, 900);
            canvas.height = canvasH * window.devicePixelRatio;
            canvas.style.height = `${canvasH}px`;

            // Reset playhead state ‚Äî start at far left
            currentPlayheadTime = 0;
            currentViewStart = 0;
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }

            // Fetch first two chunks and draw immediately
            await fetchChunk(0);
            await fetchChunk(1);
            await drawTimeRange(0, VIEW_WINDOW);
            drawPlayhead();
            drawMinimap();

            // Start background fetch of ALL remaining chunks (if auto mode)
            if (preloadMode === 'auto') {
                fetchAllChunks();
            }

            playPauseBtn.disabled = false;
            loopBtn.disabled = false;
            loadBtn.disabled = false;
            document.getElementById('cacheStatus').textContent = 'Loaded. Streaming chunks.';

            // Initialize scrub worklet (Paul stretch for minimap drag)
            if (!scrubWorkletReady) {
                initScrubWorklet().then(() => updateScrubBuffer());
            } else {
                updateScrubBuffer();
            }
        }

        // ===== DRAWING =====

        async function drawTimeRange(startSec, durationSec) {
            if (!regionData) return;

            const endSec = Math.min(startSec + durationSec, regionData.duration_seconds);
            const rawData = await getDataForTimeRange(startSec, endSec);

            if (!rawData || rawData.length === 0) {
                status.textContent = `No data for ${startSec.toFixed(1)}s - ${endSec.toFixed(1)}s`;
                return;
            }

            const nChannels = regionData.n_channels;
            const data = maybeLowPass(maybeHighPass(rawData, nChannels, regionData.sample_rate), nChannels, regionData.sample_rate);
            const nSamples = data.length / nChannels;
            const width = canvas.width;
            const height = canvas.height;
            const channelHeight = height / nChannels;
            const labelWidth = 45 * window.devicePixelRatio;  // Left margin for labels
            const waveformWidth = width - labelWidth;
            const displayGain = parseFloat(document.getElementById('gainSlider').value);

            ctx.fillStyle = '#0a0a1a';
            ctx.fillRect(0, 0, width, height);

            // Draw each channel
            for (let ch = 0; ch < nChannels; ch++) {
                const y = ch * channelHeight + channelHeight / 2;
                const color = `hsl(${(ch * 360 / nChannels)}, 70%, 60%)`;

                // Channel label on left
                const chName = regionData.channels?.[ch] || `CH${ch}`;
                const shortName = chName.replace('MEG', '');  // "MEG2112" -> "2112"
                const isSelected = selectedChannels.has(ch);
                if (isSelected) {
                    ctx.fillStyle = color;
                    ctx.font = `bold ${10 * window.devicePixelRatio}px monospace`;
                    ctx.shadowColor = color;
                    ctx.shadowBlur = 6 * window.devicePixelRatio;
                } else {
                    ctx.fillStyle = '#555';
                    ctx.font = `${10 * window.devicePixelRatio}px monospace`;
                    ctx.shadowColor = 'transparent';
                    ctx.shadowBlur = 0;
                }
                ctx.textAlign = 'right';
                ctx.textBaseline = 'middle';
                ctx.fillText(shortName, labelWidth - 15 * window.devicePixelRatio, y);
                ctx.shadowColor = 'transparent';
                ctx.shadowBlur = 0;

                // Dash line connecting label to waveform
                ctx.strokeStyle = '#444';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(labelWidth - 10 * window.devicePixelRatio, y);
                ctx.lineTo(labelWidth, y);
                ctx.stroke();

                // Baseline
                ctx.strokeStyle = '#222';
                ctx.beginPath();
                ctx.moveTo(labelWidth, y);
                ctx.lineTo(width, y);
                ctx.stroke();

                // Waveform
                ctx.strokeStyle = isSelected ? color : 'rgba(255,255,255,0.5)';
                ctx.lineWidth = isSelected ? 1.5 : 1;
                ctx.beginPath();

                const samplesPerPixel = nSamples / waveformWidth;

                for (let px = 0; px < waveformWidth; px++) {
                    const sampleIdx = Math.floor(px * samplesPerPixel);
                    const dataIdx = sampleIdx * nChannels + ch;

                    if (dataIdx < data.length) {
                        const value = data[dataIdx];
                        const normalized = value / 1e-10 * displayGain;
                        const yPos = y - normalized * (channelHeight * 0.4);

                        if (px === 0) ctx.moveTo(labelWidth + px, yPos);
                        else ctx.lineTo(labelWidth + px, yPos);
                    }
                }
                ctx.stroke();
            }

            // Eyes-closed marker
            if (startSec <= 74 && endSec >= 74) {
                const markerX = labelWidth + ((74 - startSec) / durationSec) * waveformWidth;
                ctx.strokeStyle = '#ff4444';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(markerX, 0);
                ctx.lineTo(markerX, height);
                ctx.stroke();
                ctx.fillStyle = '#ff4444';
                ctx.font = `${12 * window.devicePixelRatio}px sans-serif`;
                ctx.textAlign = 'left';
                ctx.fillText('Eyes Closed', markerX + 5, 15 * window.devicePixelRatio);
            }

            // Time range label (lower right)
            ctx.fillStyle = '#666';
            ctx.font = `${11 * window.devicePixelRatio}px monospace`;
            ctx.textAlign = 'right';
            ctx.fillText(`${startSec.toFixed(1)}s - ${endSec.toFixed(1)}s`, width - 10 * window.devicePixelRatio, height - 10 * window.devicePixelRatio);

            // Update power spectrum
            drawSpectrum(data, nChannels, regionData.sample_rate);
        }

        // ===== MINIMAP =====

        // Rebuild the cached minimap waveform image (expensive ‚Äî only when data/gain/filters change)
        function rebuildMinimapCache() {
            if (!regionData) return;
            const container = document.getElementById('minimapContainer');
            const dpr = window.devicePixelRatio;
            const w = Math.floor(container.clientWidth * dpr);
            const h = Math.floor(container.clientHeight * dpr);

            if (!minimapCacheCanvas || minimapCacheCanvas.width !== w || minimapCacheCanvas.height !== h) {
                minimapCacheCanvas = document.createElement('canvas');
                minimapCacheCanvas.width = w;
                minimapCacheCanvas.height = h;
            }
            const cctx = minimapCacheCanvas.getContext('2d');

            const totalDuration = regionData.duration_seconds;
            const nChannels = regionData.n_channels;
            const labelWidth = 45 * dpr;
            const plotWidth = w - labelWidth;

            cctx.fillStyle = '#0a0a1a';
            cctx.fillRect(0, 0, w, h);

            const channelHeight = h / nChannels;
            const displayGain = parseFloat(document.getElementById('gainSlider').value);
            const totalChunks = getTotalChunks();

            // Pre-filter chunks once
            const filteredChunks = new Map();
            for (let ci = 0; ci < totalChunks; ci++) {
                const raw = chunkCache.get(ci);
                if (raw) filteredChunks.set(ci, maybeLowPass(maybeHighPass(raw, nChannels, regionData.sample_rate), nChannels, regionData.sample_rate));
            }

            for (let ch = 0; ch < nChannels; ch++) {
                const y = ch * channelHeight + channelHeight / 2;
                const isSelected = selectedChannels.has(ch);
                const color = `hsl(${(ch * 360 / nChannels)}, 70%, 60%)`;

                cctx.strokeStyle = isSelected ? color : 'rgba(255,255,255,0.35)';
                cctx.lineWidth = isSelected ? 1.5 : 0.8;

                for (let ci = 0; ci < totalChunks; ci++) {
                    const chunkData = filteredChunks.get(ci);
                    if (!chunkData) continue;

                    const chunkStartSec = ci * CHUNK_DURATION;
                    const chunkSamples = Math.floor(chunkData.length / nChannels);
                    const chunkDurationSec = chunkSamples / regionData.sample_rate;

                    const pxStart = Math.floor((chunkStartSec / totalDuration) * plotWidth);
                    const pxEnd = Math.floor(((chunkStartSec + chunkDurationSec) / totalDuration) * plotWidth);
                    const pxWidth = Math.max(1, pxEnd - pxStart);

                    cctx.beginPath();
                    for (let px = 0; px < pxWidth; px++) {
                        const sampleIdx = Math.floor((px / pxWidth) * chunkSamples);
                        const dataIdx = sampleIdx * nChannels + ch;
                        if (dataIdx < chunkData.length) {
                            const value = chunkData[dataIdx];
                            const normalized = value / 1e-10 * displayGain;
                            const yPos = y - normalized * (channelHeight * 0.4);
                            const clampedY = Math.max(0, Math.min(h, yPos));
                            if (px === 0) cctx.moveTo(labelWidth + pxStart + px, clampedY);
                            else cctx.lineTo(labelWidth + pxStart + px, clampedY);
                        }
                    }
                    cctx.stroke();
                }
            }

            // Eyes-closed marker at 74s
            if (totalDuration >= 74) {
                const markerX = labelWidth + (74 / totalDuration) * plotWidth;
                cctx.strokeStyle = 'rgba(255,68,68,0.5)';
                cctx.lineWidth = 1;
                cctx.beginPath();
                cctx.moveTo(markerX, 0);
                cctx.lineTo(markerX, h);
                cctx.stroke();
            }

            // Outer border
            cctx.strokeStyle = 'rgba(255,255,255,0.25)';
            cctx.lineWidth = 1.5;
            cctx.strokeRect(labelWidth, 0, plotWidth, h);

            minimapCacheDirty = false;
        }

        // Fast minimap draw: blit cached waveform + draw overlay (viewport box + playhead)
        function drawMinimap() {
            if (!regionData) return;
            const container = document.getElementById('minimapContainer');
            const dpr = window.devicePixelRatio;
            const w = Math.floor(container.clientWidth * dpr);
            const h = Math.floor(container.clientHeight * dpr);

            if (minimapCanvas.width !== w || minimapCanvas.height !== h) {
                minimapCanvas.width = w;
                minimapCanvas.height = h;
                minimapCacheDirty = true;
            }

            // Rebuild cache if needed (skip during filter drag ‚Äî too expensive)
            if ((minimapCacheDirty || !minimapCacheCanvas) && !filterDragging) {
                rebuildMinimapCache();
            }

            // Blit cached waveform (skip if no cache yet)
            if (!minimapCacheCanvas) return;
            minimapCtx.drawImage(minimapCacheCanvas, 0, 0);

            // --- Overlay (cheap, every frame) ---
            const totalDuration = regionData.duration_seconds;
            const labelWidth = 45 * dpr;
            const plotWidth = w - labelWidth;

            // Viewport box
            const viewStart = currentViewStart;
            const viewEnd = Math.min(viewStart + VIEW_WINDOW, totalDuration);
            const vpLeft = labelWidth + (viewStart / totalDuration) * plotWidth;
            const vpRight = labelWidth + (viewEnd / totalDuration) * plotWidth;

            // Dim areas outside viewport
            minimapCtx.fillStyle = 'rgba(0,0,0,0.55)';
            if (vpLeft > labelWidth) minimapCtx.fillRect(labelWidth, 0, vpLeft - labelWidth, h);
            if (vpRight < w) minimapCtx.fillRect(vpRight, 0, w - vpRight, h);

            // Viewport highlight fill
            minimapCtx.fillStyle = 'rgba(95,179,179,0.2)';
            minimapCtx.fillRect(vpLeft, 0, vpRight - vpLeft, h);

            // Viewport border
            minimapCtx.strokeStyle = 'rgba(95,179,179,1.0)';
            minimapCtx.lineWidth = 2.5;
            minimapCtx.strokeRect(vpLeft, 0, vpRight - vpLeft, h);

            // Playhead line
            if (currentPlayheadTime !== null) {
                const phX = labelWidth + (currentPlayheadTime / totalDuration) * plotWidth;
                minimapCtx.strokeStyle = '#ff4444';
                minimapCtx.lineWidth = 2;
                minimapCtx.beginPath();
                minimapCtx.moveTo(phX, 0);
                minimapCtx.lineTo(phX, h);
                minimapCtx.stroke();
            }
        }

        // ===== PLAYHEAD =====

        function drawPlayhead() {
            if (currentPlayheadTime === null || !regionData) return;

            const dpr = window.devicePixelRatio;
            const width = canvas.width;
            const height = canvas.height;
            const labelWidth = 45 * dpr;
            const waveformWidth = width - labelWidth;

            // Is playhead within current view?
            const viewEnd = Math.min(currentViewStart + VIEW_WINDOW, regionData.duration_seconds);
            if (currentPlayheadTime < currentViewStart || currentPlayheadTime > viewEnd) return;

            const relativePos = (currentPlayheadTime - currentViewStart) / (viewEnd - currentViewStart);
            const phX = labelWidth + relativePos * waveformWidth;

            // Red vertical line
            ctx.strokeStyle = '#ff4444';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(phX, 0);
            ctx.lineTo(phX, height);
            ctx.stroke();

            // Small triangle cap at top
            ctx.fillStyle = '#ff4444';
            ctx.beginPath();
            ctx.moveTo(phX - 5 * dpr, 0);
            ctx.lineTo(phX + 5 * dpr, 0);
            ctx.lineTo(phX, 8 * dpr);
            ctx.closePath();
            ctx.fill();

            // Time label at upper right of playhead
            ctx.fillStyle = '#ff4444';
            ctx.font = `${13 * dpr}px 'IBM Plex Mono', monospace`;
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            ctx.fillText(`${currentPlayheadTime.toFixed(1)}s`, phX + 8 * dpr, 10 * dpr);
        }

        // ===== MONO BUFFER =====
        // Build a normalized mono mix from cached chunks + selected channels
        function buildMonoBuffer() {
            if (!regionData || selectedChannels.size === 0) return null;

            const totalDuration = regionData.duration_seconds;
            const totalSamples = Math.floor(totalDuration * regionData.sample_rate);
            const nChannels = regionData.n_channels;
            const activeChannels = [...selectedChannels];
            const nActive = activeChannels.length;

            const mono = new Float32Array(totalSamples);
            let samplesWritten = 0;

            const totalChunks = getTotalChunks();
            for (let ci = 0; ci < totalChunks; ci++) {
                const chunkData = chunkCache.get(ci);
                if (!chunkData) continue;
                const chunkSamples = Math.floor(chunkData.length / nChannels);
                const writeStart = ci * CHUNK_DURATION * regionData.sample_rate;

                for (let s = 0; s < chunkSamples; s++) {
                    let sum = 0;
                    for (let i = 0; i < nActive; i++) {
                        sum += chunkData[s * nChannels + activeChannels[i]];
                    }
                    const idx = writeStart + s;
                    if (idx < totalSamples) {
                        mono[idx] = sum / nActive;
                        samplesWritten++;
                    }
                }
            }

            if (samplesWritten === 0) return null;

            // Normalize to [-1, 1]
            let maxAbs = 0;
            for (let i = 0; i < mono.length; i++) {
                const abs = Math.abs(mono[i]);
                if (abs > maxAbs) maxAbs = abs;
            }
            if (maxAbs > 0) {
                for (let i = 0; i < mono.length; i++) {
                    mono[i] /= maxAbs;
                }
            }

            return mono;
        }

        // ===== SCRUB AUDIO (Paul Stretch) =====

        async function ensureAudioContext() {
            if (!audioContext) {
                audioContext = new AudioContext();
            }
            return audioContext;
        }

        async function initScrubWorklet() {
            const ctx = await ensureAudioContext();
            try {
                await ctx.audioWorklet.addModule('workers/paul-stretch-processor.js');
            } catch (e) {
                // Already registered ‚Äî that's fine
            }

            scrubWorkletNode = new AudioWorkletNode(ctx, 'paul-stretch-processor', {
                processorOptions: { windowSize: 4096, stretchFactor: 100 }
            });

            // Scrub filter chain: worklet ‚Üí HP ‚Üí LP ‚Üí gain ‚Üí destination
            scrubHPFilter = ctx.createBiquadFilter();
            scrubHPFilter.type = 'highpass';
            scrubHPFilter.frequency.value = highPassEnabled ? highPassFreq * 44.1 : 0;
            scrubHPFilter.Q.value = Math.SQRT1_2;

            scrubLPFilter = ctx.createBiquadFilter();
            scrubLPFilter.type = 'lowpass';
            scrubLPFilter.frequency.value = lowPassEnabled ? lowPassFreq * 44.1 : 22050;
            scrubLPFilter.Q.value = Math.SQRT1_2;

            scrubGainNode = ctx.createGain();
            scrubGainNode.gain.value = 0; // Start silent

            scrubWorkletNode.connect(scrubHPFilter);
            scrubHPFilter.connect(scrubLPFilter);
            scrubLPFilter.connect(scrubGainNode);
            scrubGainNode.connect(ctx.destination);

            scrubWorkletReady = true;
        }

        function updateScrubBuffer() {
            if (!scrubWorkletReady || !scrubWorkletNode) return;
            const mono = buildMonoBuffer();
            if (!mono) return;
            scrubMonoBuffer = mono;
            // Send a copy so the main thread retains its buffer
            const copy = new Float32Array(mono);
            scrubWorkletNode.port.postMessage({
                type: 'load-audio',
                data: { samples: Array.from(copy) }
            });
        }

        function startScrubAt(megTime) {
            if (!scrubWorkletReady || !scrubMonoBuffer) return;
            const audioPosSec = megTime / 44.1;

            // Update filters to match current settings
            scrubHPFilter.frequency.value = highPassEnabled ? highPassFreq * 44.1 : 0;
            scrubLPFilter.frequency.value = lowPassEnabled ? lowPassFreq * 44.1 : 22050;

            scrubWorkletNode.port.postMessage({ type: 'seek', data: { position: audioPosSec } });
            scrubWorkletNode.port.postMessage({ type: 'play' });

            // Fade in
            const ctx = audioContext;
            scrubGainNode.gain.cancelScheduledValues(ctx.currentTime);
            scrubGainNode.gain.setValueAtTime(scrubGainNode.gain.value, ctx.currentTime);
            scrubGainNode.gain.linearRampToValueAtTime(1, ctx.currentTime + 0.05);
        }

        function seekScrubTo(megTime) {
            if (!scrubWorkletReady || !scrubMonoBuffer) return;
            const audioPosSec = megTime / 44.1;
            // Lightweight position update ‚Äî no buffer reset, no fading.
            // The stretch algorithm naturally picks up from the new location.
            scrubWorkletNode.port.postMessage({ type: 'set-position', data: { position: audioPosSec } });
        }

        function stopScrub() {
            if (!scrubWorkletReady || !scrubWorkletNode) return;
            const ctx = audioContext;
            scrubGainNode.gain.cancelScheduledValues(ctx.currentTime);
            scrubGainNode.gain.setValueAtTime(scrubGainNode.gain.value, ctx.currentTime);
            scrubGainNode.gain.linearRampToValueAtTime(0, ctx.currentTime + 0.05);
            // Pause after fade-out
            setTimeout(() => {
                if (scrubWorkletNode) {
                    scrubWorkletNode.port.postMessage({ type: 'pause' });
                }
            }, 60);
        }

        // ===== PLAYBACK =====
        // Play 1000 Hz MEG data at 44100 Hz = 44.1x frequency shift
        // 10 Hz alpha ‚Üí 441 Hz (audible!)
        // 133 seconds of MEG ‚Üí ~3 seconds of audio

        async function playAudio() {
            if (!regionData) return;

            console.log(`[playAudio] ENTER ‚Äî currentPlayheadTime=${currentPlayheadTime}, duration=${regionData.duration_seconds}, isPlaying=${isPlaying}`);

            // If playhead is at the end, restart from beginning
            if (currentPlayheadTime !== null && currentPlayheadTime >= regionData.duration_seconds - 0.01) {
                console.log(`[playAudio] Playhead at end (${currentPlayheadTime} >= ${regionData.duration_seconds - 0.01}), resetting to 0`);
                currentPlayheadTime = 0;
                currentViewStart = 0;
            }

            if (selectedChannels.size === 0) {
                status.textContent = 'No channels selected. Click channel labels to select.';
                return;
            }

            // Build mono buffer from cached chunks
            const mono = buildMonoBuffer();
            if (!mono) {
                status.textContent = 'No data loaded yet. Wait for chunks to load.';
                return;
            }
            const totalSamples = mono.length;

            await ensureAudioContext();

            // Create buffer at 44100 Hz - 1000 Hz data ‚Üí 44.1x speedup
            const audioBuffer = audioContext.createBuffer(1, totalSamples, 44100);
            audioBuffer.copyToChannel(mono, 0);

            // Stop any existing playback
            if (audioSource) {
                audioSource.stop();
            }
            audioSource = audioContext.createBufferSource();
            audioSource.buffer = audioBuffer;

            // Route through gain node for fade-in/out
            gainNode = audioContext.createGain();
            gainNode.gain.setValueAtTime(0, audioContext.currentTime);
            gainNode.gain.linearRampToValueAtTime(1, audioContext.currentTime + FADE_MS / 1000);
            // High-pass filter node (Web Audio biquad)
            highPassFilterNode = audioContext.createBiquadFilter();
            highPassFilterNode.type = 'highpass';
            highPassFilterNode.frequency.value = highPassEnabled ? highPassFreq * 44.1 : 0;
            highPassFilterNode.Q.value = Math.SQRT1_2; // Butterworth Q

            // Low-pass filter node (Web Audio biquad)
            lowPassFilterNode = audioContext.createBiquadFilter();
            lowPassFilterNode.type = 'lowpass';
            lowPassFilterNode.frequency.value = lowPassEnabled ? lowPassFreq * 44.1 : 22050;
            lowPassFilterNode.Q.value = Math.SQRT1_2;

            audioSource.connect(highPassFilterNode);
            highPassFilterNode.connect(lowPassFilterNode);
            lowPassFilterNode.connect(gainNode);
            gainNode.connect(audioContext.destination);

            // Start from current playhead position (or beginning)
            const startMegTime = currentPlayheadTime !== null ? currentPlayheadTime : 0;
            const audioOffsetSec = startMegTime / 44.1; // Convert MEG-time to audio-time
            const bufferDuration = audioBuffer.duration;
            console.log(`[playAudio] startMegTime=${startMegTime.toFixed(4)}, audioOffsetSec=${audioOffsetSec.toFixed(4)}, bufferDuration=${bufferDuration.toFixed(4)}, remaining=${(bufferDuration - audioOffsetSec).toFixed(4)}s`);
            audioSource.start(0, audioOffsetSec);

            // Record timing references
            playStartWallTime = audioContext.currentTime;
            playStartDataOffset = startMegTime;

            isPlaying = true;
            playPauseBtn.textContent = '‚è∏Ô∏è Pause';
            playPauseBtn.classList.add('play-active');

            const audioDuration = (totalSamples / 44100) - audioOffsetSec;
            status.textContent = `Playing from ${startMegTime.toFixed(1)}s (${(audioDuration).toFixed(1)}s audio at 44.1√ó speedup)`;

            // Start animation loop
            animationTick();

            audioSource.onended = () => {
                console.log(`[onended] FIRED ‚Äî isPlaying=${isPlaying}, currentPlayheadTime=${currentPlayheadTime}, isLooping=${isLooping}`);
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                    animationFrameId = null;
                }

                // If still marked as playing, this is a natural end-of-track
                // (pauseAudio nulls onended before stopping, so this can't be a manual pause)
                const dur = regionData ? regionData.duration_seconds : 0;
                if (isPlaying) {
                    currentPlayheadTime = dur;
                    currentViewStart = Math.max(0, dur - VIEW_WINDOW);
                    const data = getDataFromCacheSync(currentViewStart, dur);
                    if (data && data.length > 0) {
                        drawTimeRangeSync(currentViewStart, VIEW_WINDOW, data);
                        drawPlayhead();
                    }
                }

                isPlaying = false;
                playPauseBtn.textContent = '‚ñ∂Ô∏è Play';
                playPauseBtn.classList.remove('play-active');
                drawMinimap();
                if (isLooping) {
                    currentPlayheadTime = 0;
                    currentViewStart = 0;
                    playAudio();
                } else {
                    status.textContent = 'Playback complete.';
                }
            };
        }

        // ===== ANIMATION LOOP =====

        let spectrumThrottle = 0;

        function animationTick() {
            if (!isPlaying || !regionData) return;

            // Calculate current MEG-time from AudioContext
            const wallElapsed = audioContext.currentTime - playStartWallTime;
            const megTime = playStartDataOffset + wallElapsed * 44.1;
            const totalDuration = regionData.duration_seconds;

            if (megTime >= totalDuration) {
                // Playback reached end ‚Äî draw final frame, then stop
                console.log(`[animationTick] END OF TRACK ‚Äî megTime=${megTime.toFixed(4)}, totalDuration=${totalDuration.toFixed(4)}, wallElapsed=${wallElapsed.toFixed(4)}`);
                currentPlayheadTime = totalDuration;
                currentViewStart = Math.max(0, totalDuration - VIEW_WINDOW);
                const viewEnd = totalDuration;
                const data = getDataFromCacheSync(currentViewStart, viewEnd);
                if (data && data.length > 0) {
                    drawTimeRangeSync(currentViewStart, VIEW_WINDOW, data);
                    drawPlayhead();
                }

                // Detach onended before stopping so it doesn't interfere
                if (audioSource) audioSource.onended = null;
                isPlaying = false;
                playPauseBtn.textContent = '‚ñ∂Ô∏è Play';
                playPauseBtn.classList.remove('play-active');
                drawMinimap();
                if (isLooping) {
                    currentPlayheadTime = 0;
                    currentViewStart = 0;
                    playAudio();
                }
                return;
            }

            currentPlayheadTime = megTime;

            // Three-phase viewport calculation
            const halfWindow = VIEW_WINDOW / 2;
            if (megTime < halfWindow) {
                // Lead-in: window fixed at start, playhead moves left‚Üícenter
                currentViewStart = 0;
            } else if (megTime > totalDuration - halfWindow) {
                // Lead-out: window fixed at end, playhead moves center‚Üíright
                currentViewStart = totalDuration - VIEW_WINDOW;
            } else {
                // Scrolling: playhead at center, window slides
                currentViewStart = megTime - halfWindow;
            }
            currentViewStart = Math.max(0, currentViewStart);

            // Get data from cache synchronously
            const viewEnd = Math.min(currentViewStart + VIEW_WINDOW, totalDuration);
            const data = getDataFromCacheSync(currentViewStart, viewEnd);

            if (data && data.length > 0) {
                // Filter once, reuse for both waveform and spectrum
                const filteredData = applyFilters(data, regionData.n_channels, regionData.sample_rate);

                drawTimeRangeSync(currentViewStart, VIEW_WINDOW, filteredData, true);
                drawPlayhead();

                // Throttle spectrum to ~10fps
                spectrumThrottle++;
                if (spectrumThrottle % 6 === 0) {
                    drawSpectrum(filteredData, regionData.n_channels, regionData.sample_rate);
                }
            }

            // Redraw minimap (viewport box + playhead position)
            drawMinimap();

            animationFrameId = requestAnimationFrame(animationTick);
        }

        // Synchronous version of drawTimeRange that takes pre-filtered data
        // If preFiltered=true, data is already filtered ‚Äî skip filter step
        // Pre-computed channel colors (built once per region load)
        let _channelColors = [];
        let _channelShortNames = [];
        let _cachedGainSlider = null;

        function _buildChannelCache(nChannels) {
            _channelColors = new Array(nChannels);
            _channelShortNames = new Array(nChannels);
            for (let ch = 0; ch < nChannels; ch++) {
                _channelColors[ch] = `hsl(${(ch * 360 / nChannels)}, 70%, 60%)`;
                const chName = regionData.channels?.[ch] || `CH${ch}`;
                _channelShortNames[ch] = chName.replace('MEG', '');
            }
            _cachedGainSlider = document.getElementById('gainSlider');
        }

        function drawTimeRangeSync(startSec, durationSec, rawData, preFiltered) {
            if (!regionData || !rawData || rawData.length === 0) return;

            const endSec = Math.min(startSec + durationSec, regionData.duration_seconds);
            const nChannels = regionData.n_channels;
            const data = preFiltered ? rawData : maybeLowPass(maybeHighPass(rawData, nChannels, regionData.sample_rate), nChannels, regionData.sample_rate);
            const nSamples = data.length / nChannels;
            const dpr = window.devicePixelRatio;
            const width = canvas.width;
            const height = canvas.height;
            const channelHeight = height / nChannels;
            const labelWidth = 45 * dpr;
            const waveformWidth = width - labelWidth;
            const displayGain = parseFloat((_cachedGainSlider || document.getElementById('gainSlider')).value);
            const gainScale = displayGain / 1e-10;
            const halfChanH = channelHeight * 0.4;

            ctx.fillStyle = '#0a0a1a';
            ctx.fillRect(0, 0, width, height);

            // Ensure channel cache is built
            if (_channelColors.length !== nChannels) _buildChannelCache(nChannels);

            const fontNormal = `${10 * dpr}px monospace`;
            const fontBold = `bold ${10 * dpr}px monospace`;
            const samplesPerPixel = nSamples / waveformWidth;

            // Draw labels for all channels
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';
            for (let ch = 0; ch < nChannels; ch++) {
                const y = ch * channelHeight + channelHeight / 2;
                const isSelected = selectedChannels.has(ch);
                ctx.fillStyle = isSelected ? _channelColors[ch] : '#555';
                ctx.font = isSelected ? fontBold : fontNormal;
                ctx.fillText(_channelShortNames[ch], labelWidth - 15 * dpr, y);
            }

            // Batch all unselected channels into ONE path (same color/width)
            ctx.strokeStyle = 'rgba(255,255,255,0.5)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            for (let ch = 0; ch < nChannels; ch++) {
                if (selectedChannels.has(ch)) continue;
                const y = ch * channelHeight + channelHeight / 2;
                for (let px = 0; px < waveformWidth; px++) {
                    const sampleIdx = Math.floor(px * samplesPerPixel);
                    const dataIdx = sampleIdx * nChannels + ch;
                    if (dataIdx < data.length) {
                        const yPos = y - data[dataIdx] * gainScale * halfChanH;
                        if (px === 0) ctx.moveTo(labelWidth, yPos);
                        else ctx.lineTo(labelWidth + px, yPos);
                    }
                }
            }
            ctx.stroke();

            // Draw selected channels individually (each has unique color)
            for (let ch = 0; ch < nChannels; ch++) {
                if (!selectedChannels.has(ch)) continue;
                const y = ch * channelHeight + channelHeight / 2;
                ctx.strokeStyle = _channelColors[ch];
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                for (let px = 0; px < waveformWidth; px++) {
                    const sampleIdx = Math.floor(px * samplesPerPixel);
                    const dataIdx = sampleIdx * nChannels + ch;
                    if (dataIdx < data.length) {
                        const yPos = y - data[dataIdx] * gainScale * halfChanH;
                        if (px === 0) ctx.moveTo(labelWidth, yPos);
                        else ctx.lineTo(labelWidth + px, yPos);
                    }
                }
                ctx.stroke();
            }

            // Eyes-closed marker
            if (startSec <= 74 && endSec >= 74) {
                const markerX = labelWidth + ((74 - startSec) / durationSec) * waveformWidth;
                ctx.strokeStyle = '#ff4444';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(markerX, 0);
                ctx.lineTo(markerX, height);
                ctx.stroke();
                ctx.fillStyle = '#ff4444';
                ctx.font = `${12 * dpr}px sans-serif`;
                ctx.textAlign = 'left';
                ctx.fillText('Eyes Closed', markerX + 5, 15 * dpr);
            }

            // Time range label
            ctx.fillStyle = '#666';
            ctx.font = `${11 * dpr}px monospace`;
            ctx.textAlign = 'right';
            ctx.fillText(`${startSec.toFixed(1)}s - ${endSec.toFixed(1)}s`, width - 10 * dpr, height - 10 * dpr);
        }

        function pauseAudio() {
            console.log(`[pauseAudio] ENTER ‚Äî isPlaying=${isPlaying}, currentPlayheadTime=${currentPlayheadTime}`);
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
            isPlaying = false;
            playPauseBtn.textContent = '‚ñ∂Ô∏è Play';
            playPauseBtn.classList.remove('play-active');
            drawMinimap();

            if (audioSource) {
                audioSource.onended = null;  // Prevent stale callback
                if (gainNode && audioContext) {
                    // Fade out over 25ms, then stop
                    gainNode.gain.cancelScheduledValues(audioContext.currentTime);
                    gainNode.gain.setValueAtTime(gainNode.gain.value, audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + FADE_MS / 1000);
                    const src = audioSource;
                    setTimeout(() => { try { src.stop(); } catch(e) {} }, FADE_MS);
                } else {
                    audioSource.stop();
                }
                audioSource = null;
                gainNode = null;
            }
        }

        function togglePlayPause() {
            console.log(`[togglePlayPause] isPlaying=${isPlaying}, currentPlayheadTime=${currentPlayheadTime}`);
            if (isPlaying) {
                pauseAudio();
            } else {
                playAudio();
            }
        }

        // ===== EVENT LISTENERS =====

        loadBtn.addEventListener('click', loadRegion);
        playPauseBtn.addEventListener('click', (e) => {
            e.target.blur();
            togglePlayPause();
        });
        loopBtn.addEventListener('click', (e) => {
            e.target.blur();
            isLooping = !isLooping;
            loopBtn.textContent = isLooping ? 'üîÅ Loop ON' : 'üîÅ Loop';
            loopBtn.classList.toggle('loop-active', isLooping);
        });

        // Spacebar toggles play/pause, L toggles loop (always, regardless of focus)
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                document.activeElement?.blur();
                togglePlayPause();
            } else if (e.key === 'l' || e.key === 'L') {
                if (e.target.matches('input, select, textarea')) return;
                isLooping = !isLooping;
                loopBtn.textContent = isLooping ? 'üîÅ Loop ON' : 'üîÅ Loop';
                loopBtn.classList.toggle('loop-active', isLooping);
            }
        });

        // Channel selection (label area) and click-to-seek (waveform area)
        canvas.addEventListener('click', async (e) => {
            if (!regionData) return;
            const rect = canvas.getBoundingClientRect();
            const clickY = (e.clientY - rect.top) * window.devicePixelRatio;
            const nChannels = regionData.n_channels;
            const height = canvas.height;
            const channelHeight = height / nChannels;
            const labelWidth = 45 * window.devicePixelRatio;
            const clickX = (e.clientX - rect.left) * window.devicePixelRatio;

            if (clickX <= labelWidth) {
                // Label area: toggle channel selection
                const ch = Math.floor(clickY / channelHeight);
                if (ch < 0 || ch >= nChannels) return;

                if (selectedChannels.has(ch)) {
                    selectedChannels.delete(ch);
                } else {
                    selectedChannels.add(ch);
                }

                // Redraw with current view
                minimapCacheDirty = true;
                await drawTimeRange(currentViewStart, VIEW_WINDOW);
                drawPlayhead();
                drawMinimap();

                // If playing, rebuild audio with updated channel mix
                if (isPlaying) {
                    pauseAudio();
                    playAudio();
                }
                // Update scrub buffer with new channel selection
                updateScrubBuffer();
            } else {
                // Waveform area: click-to-seek
                const waveformWidth = canvas.width - labelWidth;
                const relX = (clickX - labelWidth) / waveformWidth;
                const viewEnd = Math.min(currentViewStart + VIEW_WINDOW, regionData.duration_seconds);
                const clickedTime = currentViewStart + relX * (viewEnd - currentViewStart);

                currentPlayheadTime = Math.max(0, Math.min(clickedTime, regionData.duration_seconds));

                if (isPlaying) {
                    // Restart audio from new position
                    pauseAudio();
                    playAudio();
                } else {
                    // Center view on clicked time and redraw
                    navigateToTime(currentPlayheadTime);
                }
            }
        });

        // Pointer cursor over label area, crosshair over waveform
        canvas.addEventListener('mousemove', (e) => {
            if (!regionData) return;
            const rect = canvas.getBoundingClientRect();
            const clickX = (e.clientX - rect.left) * window.devicePixelRatio;
            const labelWidth = 45 * window.devicePixelRatio;
            canvas.style.cursor = clickX <= labelWidth ? 'pointer' : 'crosshair';
        });

        // Minimap click & drag: scrub playhead across the recording
        let minimapDragging = false;
        let minimapWasPlaying = false;

        function minimapScrub(e) {
            if (!regionData) return;
            const rect = minimapCanvas.getBoundingClientRect();
            const labelWidthCSS = 45;  // Match label area in CSS pixels
            const plotWidthCSS = rect.width - labelWidthCSS;
            const clickX = Math.max(0, Math.min(e.clientX - rect.left - labelWidthCSS, plotWidthCSS));
            const totalDuration = regionData.duration_seconds;

            const scrubTime = (clickX / plotWidthCSS) * totalDuration;
            currentPlayheadTime = Math.max(0, Math.min(scrubTime, totalDuration));

            // Navigate synchronously using cached data for responsiveness
            const halfWindow = VIEW_WINDOW / 2;
            if (currentPlayheadTime < halfWindow) {
                currentViewStart = 0;
            } else if (currentPlayheadTime > totalDuration - halfWindow) {
                currentViewStart = Math.max(0, totalDuration - VIEW_WINDOW);
            } else {
                currentViewStart = currentPlayheadTime - halfWindow;
            }

            const viewEnd = Math.min(currentViewStart + VIEW_WINDOW, totalDuration);
            const data = getDataFromCacheSync(currentViewStart, viewEnd);
            if (data && data.length > 0) {
                const filteredData = applyFilters(data, regionData.n_channels, regionData.sample_rate);
                drawTimeRangeSync(currentViewStart, VIEW_WINDOW, filteredData, true);
                drawPlayhead();
                drawSpectrum(filteredData, regionData.n_channels, regionData.sample_rate);
            }
            drawMinimap();
        }

        minimapCanvas.addEventListener('mousedown', (e) => {
            if (!regionData) return;
            minimapDragging = true;
            minimapWasPlaying = isPlaying;
            if (isPlaying) pauseAudio();
            minimapScrub(e);
            // Start scrub audio at this position
            startScrubAt(currentPlayheadTime);
        });

        document.addEventListener('mousemove', (e) => {
            if (!minimapDragging) return;
            minimapScrub(e);
            // Seek scrub audio to new position
            seekScrubTo(currentPlayheadTime);
        });

        document.addEventListener('mouseup', () => {
            if (minimapDragging) {
                stopScrub();
                if (minimapWasPlaying) {
                    playAudio();
                }
            }
            minimapDragging = false;
            minimapWasPlaying = false;
        });

        // Navigate to a specific time: center view and redraw
        async function navigateToTime(megTime) {
            if (!regionData) return;
            const totalDuration = regionData.duration_seconds;
            const halfWindow = VIEW_WINDOW / 2;

            if (megTime < halfWindow) {
                currentViewStart = 0;
            } else if (megTime > totalDuration - halfWindow) {
                currentViewStart = Math.max(0, totalDuration - VIEW_WINDOW);
            } else {
                currentViewStart = megTime - halfWindow;
            }

            await drawTimeRange(currentViewStart, VIEW_WINDOW);
            drawPlayhead();
            drawMinimap();
        }

        // Preload mode toggle
        preloadToggle.addEventListener('click', () => {
            if (preloadMode === 'auto') {
                preloadMode = 'ondemand';
                preloadToggle.textContent = 'Preload: On Demand';
                preloadToggle.style.background = '#8a5555';
            } else {
                preloadMode = 'auto';
                preloadToggle.textContent = 'Preload: Auto';
                preloadToggle.style.background = '#4a7a5a';
                if (regionData && !isUploadedData) {
                    fetchAllChunks();
                }
            }
        });

        // Gain slider - redraw waveform with new amplitude
        const gainSlider = document.getElementById('gainSlider');
        const gainValueEl = document.getElementById('gainValue');
        gainSlider.addEventListener('input', async () => {
            const gain = parseFloat(gainSlider.value);
            gainValueEl.textContent = gain.toFixed(2);
            if (regionData) {
                minimapCacheDirty = true;
                await drawTimeRange(currentViewStart, VIEW_WINDOW);
                drawPlayhead();
                drawMinimap();
            }
        });

        // Filter controls now live on the spectrum plot ‚Äî see spectrum mouse handlers below

        /*
        ============================================================
        COMMENTED OUT: Browser-based .mat upload functionality

        Reason: Large files (1 hour MEG = ~4GB) exceed browser memory.
        For now, datasets are curated via scripts/export_regions.py.
        ============================================================

        // ===== TAB HANDLING =====
        const tabDemo = document.getElementById('tabDemo');
        const tabUpload = document.getElementById('tabUpload');
        const contentDemo = document.getElementById('contentDemo');
        const contentUpload = document.getElementById('contentUpload');

        tabDemo.addEventListener('click', () => {
            tabDemo.classList.add('active');
            tabUpload.classList.remove('active');
            contentDemo.classList.add('active');
            contentUpload.classList.remove('active');
        });

        tabUpload.addEventListener('click', () => {
            tabUpload.classList.add('active');
            tabDemo.classList.remove('active');
            contentUpload.classList.add('active');
            contentDemo.classList.remove('active');
            fileInput.click();
        });

        // ===== FILE UPLOAD HANDLING =====
        let uploadedMatData = null;
        let uploadedChannelNames = [];
        let uploadedSampleRate = 1000;

        const uploadStatus = document.getElementById('uploadStatus');
        const fileInput = document.getElementById('fileInput');
        const uploadControls = document.getElementById('uploadControls');
        const channelSelector = document.getElementById('channelSelector');
        const loadUploadedBtn = document.getElementById('loadUploadedBtn');

        fileInput.addEventListener('change', () => {
            if (fileInput.files.length) {
                handleMatFile(fileInput.files[0]);
            }
        });

        async function handleMatFile(file) {
            status.textContent = `Parsing ${file.name}...`;
            try {
                const arrayBuffer = await file.arrayBuffer();
                const mat = MatParser.read(arrayBuffer);
                let dataKey = Object.keys(mat).find(k =>
                    k.toLowerCase().includes('data') && !k.includes('filt')
                ) || Object.keys(mat)[0];
                const rawData = mat[dataKey];
                if (!rawData || !rawData.length) {
                    throw new Error('No data array found in .mat file');
                }
                const nChannels = rawData.length;
                const nSamples = rawData[0]?.length || 0;
                uploadedMatData = rawData;
                if (mat.ch_names) {
                    uploadedChannelNames = mat.ch_names;
                } else {
                    uploadedChannelNames = Array.from({length: nChannels}, (_, i) => `CH${i}`);
                }
                const megIndices = [];
                uploadedChannelNames.forEach((name, i) => {
                    if (typeof name === 'string' && name.startsWith('MEG')) {
                        megIndices.push(i);
                    }
                });
                channelSelector.innerHTML = '';
                uploadedChannelNames.forEach((name, i) => {
                    const isMeg = megIndices.includes(i);
                    const label = document.createElement('label');
                    label.innerHTML = `<input type="checkbox" value="${i}" ${isMeg ? 'checked' : ''}><span>${name}</span>`;
                    channelSelector.appendChild(label);
                });
                uploadControls.style.display = 'block';
                uploadStatus.innerHTML = `‚úì ${file.name} (${nChannels} ch √ó ${(nSamples/1000).toFixed(1)}s)`;
            } catch (err) {
                status.textContent = `Error parsing .mat file: ${err.message}`;
                console.error(err);
            }
        }

        function selectChannelRange(start, count) {
            const checkboxes = channelSelector.querySelectorAll('input[type="checkbox"]');
            checkboxes.forEach((cb, i) => {
                cb.checked = (i >= start && i < start + count);
            });
        }
        function selectAllChannels() {
            channelSelector.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = true);
        }
        function selectNoChannels() {
            channelSelector.querySelectorAll('input[type="checkbox"]').forEach(cb => cb.checked = false);
        }

        loadUploadedBtn.addEventListener('click', async () => {
            if (!uploadedMatData) return;
            const selectedIndices = [];
            const selectedNames = [];
            channelSelector.querySelectorAll('input[type="checkbox"]:checked').forEach(cb => {
                const idx = parseInt(cb.value);
                selectedIndices.push(idx);
                selectedNames.push(uploadedChannelNames[idx]);
            });
            if (selectedIndices.length === 0) {
                status.textContent = 'Please select at least one channel';
                return;
            }
            const nChannels = selectedIndices.length;
            const nSamples = uploadedMatData[0].length;
            const interleaved = new Float32Array(nSamples * nChannels);
            for (let s = 0; s < nSamples; s++) {
                for (let c = 0; c < nChannels; c++) {
                    interleaved[s * nChannels + c] = uploadedMatData[selectedIndices[c]][s];
                }
            }
            chunkCache = new Map();
            chunkCache.set(0, interleaved);
            isUploadedData = true;
            regionData = {
                description: `Uploaded (${nChannels} ch)`,
                channels: selectedNames,
                n_channels: nChannels,
                n_samples: nSamples,
                sample_rate: uploadedSampleRate,
                duration_seconds: nSamples / uploadedSampleRate,
            };
            _buildChannelCache(nChannels);
            info.innerHTML = `
                <strong>Uploaded Data</strong><br>
                Channels: ${nChannels} | Duration: ${regionData.duration_seconds.toFixed(1)}s | Sample rate: ${uploadedSampleRate} Hz
            `;
            canvas.width = canvas.offsetWidth * window.devicePixelRatio;
            canvas.height = Math.min(nChannels * 25, 900) * window.devicePixelRatio;
            canvas.style.height = `${Math.min(nChannels * 25, 900)}px`;
            seekSlider.max = regionData.duration_seconds;
            totalTimeEl.textContent = `${regionData.duration_seconds.toFixed(2)}s`;
            cacheIndicator.innerHTML = '<div style="color: #5FB3B3; font-size: 12px;">All data in memory</div>';
            await drawTimeRange(0, 5);
            playBtn.disabled = false;
            stopBtn.disabled = false;
            status.textContent = `Loaded ${nChannels} channels. Ready to explore!`;
        });
        */

        // ===== FFT & POWER SPECTRUM =====

        // Radix-2 Cooley-Tukey FFT (in-place)
        function fft(re, im) {
            const n = re.length;
            // Bit-reversal permutation
            for (let i = 1, j = 0; i < n; i++) {
                let bit = n >> 1;
                while (j & bit) { j ^= bit; bit >>= 1; }
                j ^= bit;
                if (i < j) {
                    [re[i], re[j]] = [re[j], re[i]];
                    [im[i], im[j]] = [im[j], im[i]];
                }
            }
            // FFT butterfly
            for (let len = 2; len <= n; len <<= 1) {
                const halfLen = len >> 1;
                const angle = -2 * Math.PI / len;
                const wRe = Math.cos(angle);
                const wIm = Math.sin(angle);
                for (let i = 0; i < n; i += len) {
                    let curRe = 1, curIm = 0;
                    for (let j = 0; j < halfLen; j++) {
                        const tRe = curRe * re[i + j + halfLen] - curIm * im[i + j + halfLen];
                        const tIm = curRe * im[i + j + halfLen] + curIm * re[i + j + halfLen];
                        re[i + j + halfLen] = re[i + j] - tRe;
                        im[i + j + halfLen] = im[i + j] - tIm;
                        re[i + j] += tRe;
                        im[i + j] += tIm;
                        const newCurRe = curRe * wRe - curIm * wIm;
                        curIm = curRe * wIm + curIm * wRe;
                        curRe = newCurRe;
                    }
                }
            }
        }

        // Compute power spectrum from time-interleaved data
        // Returns { freqs: Float64Array, power: Float64Array } in original MEG Hz
        // Pre-allocated FFT buffers to avoid per-call allocation
        let _fftRe = null, _fftIm = null, _fftMono = null;
        let _fftPower = null, _fftFreqs = null;
        let _fftSize = 0;

        function computeSpectrum(data, nChannels, sampleRate) {
            if (selectedChannels.size === 0) return null;

            const nSamples = Math.floor(data.length / nChannels);
            const activeChannels = [...selectedChannels];
            const nActive = activeChannels.length;

            // Determine FFT size (next power of 2)
            let fftSize = 1;
            while (fftSize < nSamples) fftSize <<= 1;

            // Re-allocate buffers only when FFT size changes
            if (fftSize !== _fftSize) {
                _fftSize = fftSize;
                _fftRe = new Float64Array(fftSize);
                _fftIm = new Float64Array(fftSize);
                _fftMono = new Float64Array(nSamples);
                _fftPower = new Float64Array(fftSize / 2);
                _fftFreqs = new Float64Array(fftSize / 2);
            } else {
                // Zero out (re may have leftover from last call, im must be zero)
                _fftRe.fill(0);
                _fftIm.fill(0);
            }

            // Ensure mono buffer is large enough
            if (!_fftMono || _fftMono.length < nSamples) {
                _fftMono = new Float64Array(nSamples);
            }

            // Average selected channels into mono
            for (let s = 0; s < nSamples; s++) {
                let sum = 0;
                for (let i = 0; i < nActive; i++) {
                    sum += data[s * nChannels + activeChannels[i]];
                }
                _fftMono[s] = sum / nActive;
            }

            // Apply Hann window into FFT real buffer
            for (let i = 0; i < nSamples; i++) {
                const w = 0.5 * (1 - Math.cos(2 * Math.PI * i / (nSamples - 1)));
                _fftRe[i] = _fftMono[i] * w;
            }

            fft(_fftRe, _fftIm);

            // Power spectrum (magnitude squared), only positive frequencies
            const nBins = fftSize / 2;
            const freqRes = sampleRate / fftSize;

            for (let i = 0; i < nBins; i++) {
                _fftFreqs[i] = i * freqRes;
                _fftPower[i] = _fftRe[i] * _fftRe[i] + _fftIm[i] * _fftIm[i];
            }

            // Convert to dB
            let maxPower = 0;
            for (let i = 1; i < nBins; i++) {
                if (_fftPower[i] > maxPower) maxPower = _fftPower[i];
            }
            if (maxPower > 0) {
                for (let i = 0; i < nBins; i++) {
                    _fftPower[i] = 10 * Math.log10(_fftPower[i] / maxPower + 1e-12);
                }
            }

            return { freqs: _fftFreqs, power: _fftPower, nBins, freqRes };
        }

        // Cached spectrum state for hover interaction
        let lastSpectrumState = null;
        let spectrumHoverX = -1;

        // Offscreen cache for spectrum base layer (grid + curve, no filter overlay)
        let _spectrumBaseCanvas = null;
        let _spectrumBaseDirty = true;

        // Lightweight redraw: blit cached spectrum base + redraw filter overlay only
        // Used during filter drag to avoid recomputing FFT
        function redrawSpectrumOverlay() {
            if (!_spectrumBaseCanvas || !lastSpectrumState) return;
            const s = lastSpectrumState;
            specCtx.drawImage(_spectrumBaseCanvas, 0, 0);
            drawFilterOverlay(specCtx, s.pad, s.plotW, s.plotH, s.w, s.h, s.dpr, s.freqToX, s.handleTrackH);
            if (spectrumHoverX >= 0) drawSpectrumHover(spectrumHoverVisible);
        }

        // Draw filter handles and shaded rejection regions on spectrum
        function drawFilterOverlay(ctx, pad, plotW, plotH, w, h, dpr, freqToX, handleTrackH) {
            const trackY = 0;
            const trackH = handleTrackH;
            const triSize = 6 * dpr;  // triangle half-width
            const activeColor = '#4db8ff';       // hot blue
            const dimColor = 'rgba(77,184,255,0.25)';

            // --- Shaded rejection regions on the plot area ---
            if (highPassEnabled) {
                const hpX = freqToX(highPassFreq);
                ctx.fillStyle = 'rgba(0, 0, 0, 0.55)';
                ctx.fillRect(pad.left, pad.top, hpX - pad.left, plotH);
                ctx.strokeStyle = 'rgba(77,184,255,0.5)';
                ctx.lineWidth = 1.5;
                ctx.setLineDash([4 * dpr, 3 * dpr]);
                ctx.beginPath();
                ctx.moveTo(hpX, pad.top);
                ctx.lineTo(hpX, pad.top + plotH);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            if (lowPassEnabled) {
                const lpX = freqToX(lowPassFreq);
                ctx.fillStyle = 'rgba(0, 0, 0, 0.55)';
                ctx.fillRect(lpX, pad.top, pad.left + plotW - lpX, plotH);
                ctx.strokeStyle = 'rgba(77,184,255,0.5)';
                ctx.lineWidth = 1.5;
                ctx.setLineDash([4 * dpr, 3 * dpr]);
                ctx.beginPath();
                ctx.moveTo(lpX, pad.top);
                ctx.lineTo(lpX, pad.top + plotH);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            // --- Handle track background ---
            ctx.fillStyle = 'rgba(255,255,255,0.03)';
            ctx.fillRect(pad.left, trackY, plotW, trackH);

            // --- HP handle: downward triangle ---
            const hpX = freqToX(highPassFreq);
            const hpColor = highPassEnabled ? activeColor : dimColor;
            ctx.fillStyle = hpColor;
            ctx.beginPath();
            ctx.moveTo(hpX - triSize, trackY + 2 * dpr);
            ctx.lineTo(hpX + triSize, trackY + 2 * dpr);
            ctx.lineTo(hpX, trackY + 2 * dpr + triSize * 1.5);
            ctx.closePath();
            ctx.fill();

            // HP label
            ctx.font = `bold ${11 * dpr}px 'IBM Plex Mono', monospace`;
            ctx.fillStyle = hpColor;
            ctx.textAlign = 'left';
            ctx.textBaseline = 'middle';
            ctx.fillText(`HP ${highPassFreq.toFixed(1)}`, hpX + triSize + 3 * dpr, trackY + trackH / 2);

            // --- LP handle: downward triangle ---
            const lpX = freqToX(lowPassFreq);
            const lpColor = lowPassEnabled ? activeColor : dimColor;
            ctx.fillStyle = lpColor;
            ctx.beginPath();
            ctx.moveTo(lpX - triSize, trackY + 2 * dpr);
            ctx.lineTo(lpX + triSize, trackY + 2 * dpr);
            ctx.lineTo(lpX, trackY + 2 * dpr + triSize * 1.5);
            ctx.closePath();
            ctx.fill();

            // LP label ‚Äî flip to left side if too close to right edge
            ctx.font = `bold ${11 * dpr}px 'IBM Plex Mono', monospace`;
            ctx.fillStyle = lpColor;
            const lpLabelText = `LP ${lowPassFreq.toFixed(1)}`;
            const lpLabelW = ctx.measureText(lpLabelText).width;
            const lpRightEdge = lpX + triSize + 3 * dpr + lpLabelW;
            if (lpRightEdge > pad.left + plotW) {
                ctx.textAlign = 'right';
                ctx.textBaseline = 'middle';
                ctx.fillText(lpLabelText, lpX - triSize - 3 * dpr, trackY + trackH / 2);
            } else {
                ctx.textAlign = 'left';
                ctx.textBaseline = 'middle';
                ctx.fillText(lpLabelText, lpX + triSize + 3 * dpr, trackY + trackH / 2);
            }
        }

        // Draw power spectrum line plot
        function drawSpectrum(data, nChannels, sampleRate) {
            if (data) window._lastSpectrumArgs = [data, nChannels, sampleRate];
            const container = document.getElementById('spectrumContainer');
            const dpr = window.devicePixelRatio;
            const targetW = Math.floor(container.clientWidth * dpr);
            const targetH = Math.floor(container.clientHeight * dpr);

            // Only resize canvas when dimensions actually change (resizing clears & reallocates)
            if (spectrumCanvas.width !== targetW || spectrumCanvas.height !== targetH) {
                spectrumCanvas.width = targetW;
                spectrumCanvas.height = targetH;
                spectrumCanvas.style.width = '100%';
                spectrumCanvas.style.height = '100%';
            }

            const w = spectrumCanvas.width;
            const h = spectrumCanvas.height;
            const handleTrackH = 18 * dpr;  // height of handle area at top
            const pad = { left: 45 * dpr, right: 10 * dpr, top: handleTrackH + 4 * dpr, bottom: 24 * dpr };
            const plotW = w - pad.left - pad.right;
            const plotH = h - pad.top - pad.bottom;

            specCtx.fillStyle = '#0a0a1a';
            specCtx.fillRect(0, 0, w, h);

            // X range: 0 to 100 Hz (sqrt-scaled so low freqs get more room)
            const maxFreq = 100;
            const minFreq = 0.5;
            const freqToX = (f) => {
                if (f <= minFreq) return pad.left;
                return pad.left + ((Math.sqrt(f) - Math.sqrt(minFreq)) / (Math.sqrt(maxFreq) - Math.sqrt(minFreq))) * plotW;
            };
            // Y range: dB (typically -60 to 0)
            const dbMin = -60;
            const dbMax = 0;

            // Plot area background (lighter than outer)
            specCtx.fillStyle = '#10102a';
            specCtx.fillRect(pad.left, pad.top, plotW, plotH);

            // Grid lines
            specCtx.strokeStyle = 'rgba(255,255,255,0.12)';
            specCtx.lineWidth = 1;
            specCtx.font = `${11 * dpr}px 'IBM Plex Mono', monospace`;
            specCtx.fillStyle = 'rgba(224,224,224,0.4)';

            // Frequency axis labels (log-spaced)
            const freqTicks = [1, 5, 10, 20, 50, 100];
            specCtx.textAlign = 'center';
            specCtx.textBaseline = 'top';
            for (const f of freqTicks) {
                if (f > maxFreq) continue;
                const x = freqToX(f);
                specCtx.beginPath();
                specCtx.moveTo(x, pad.top);
                specCtx.lineTo(x, pad.top + plotH);
                specCtx.stroke();
                specCtx.fillText(`${f}`, x, pad.top + plotH + 4 * dpr);
            }

            // dB axis labels
            specCtx.textAlign = 'right';
            specCtx.textBaseline = 'middle';
            for (let db = dbMin; db <= dbMax; db += 20) {
                const y = pad.top + ((dbMax - db) / (dbMax - dbMin)) * plotH;
                // Grid line
                specCtx.beginPath();
                specCtx.moveTo(pad.left, y);
                specCtx.lineTo(pad.left + plotW, y);
                specCtx.stroke();
                // Label (pushed further left)
                specCtx.fillText(`${db}`, pad.left - 12 * dpr, y);
                // Tick dash connecting label to plot (like waveform)
                specCtx.strokeStyle = '#444';
                specCtx.beginPath();
                specCtx.moveTo(pad.left - 8 * dpr, y);
                specCtx.lineTo(pad.left, y);
                specCtx.stroke();
                specCtx.strokeStyle = 'rgba(255,255,255,0.12)';
            }

            // "Hz" label
            specCtx.textAlign = 'center';
            specCtx.fillStyle = 'rgba(224,224,224,0.3)';
            specCtx.fillText('Hz', pad.left + plotW / 2, h - 7 * dpr);

            // Band markers (alpha, beta, etc.)
            const bands = [
                { name: 'Œ¥', lo: 0.5, hi: 4, color: 'rgba(224,224,224,0.5)' },
                { name: 'Œ∏', lo: 4, hi: 8, color: 'rgba(224,224,224,0.5)' },
                { name: 'Œ±', lo: 8, hi: 13, color: '#dd6666' },
                { name: 'Œ≤', lo: 13, hi: 30, color: 'rgba(224,224,224,0.5)' },
                { name: 'Œ≥', lo: 30, hi: 100, color: 'rgba(224,224,224,0.5)' },
            ];
            for (const b of bands) {
                const x1 = freqToX(b.lo);
                const x2 = freqToX(Math.min(b.hi, maxFreq));
                specCtx.fillStyle = b.color === '#dd6666' ? 'rgba(221,102,102,0.15)' : 'rgba(255,255,255,0.02)';
                specCtx.fillRect(x1, pad.top, x2 - x1, plotH);
                specCtx.fillStyle = b.color;
                specCtx.font = `bold ${12 * dpr}px 'IBM Plex Mono', monospace`;
                specCtx.textAlign = 'center';
                specCtx.textBaseline = 'top';
                specCtx.fillText(b.name, (x1 + x2) / 2, pad.top + 1 * dpr);
            }

            // Border
            specCtx.strokeStyle = 'rgba(255,255,255,0.3)';
            specCtx.lineWidth = 1.5;
            specCtx.strokeRect(pad.left, pad.top, plotW, plotH);

            // Cache layout state so filter handles are interactive even without data
            lastSpectrumState = { freqs: null, power: null, nBins: 0, pad, plotW, plotH, w, h, dpr, dbMin, dbMax, maxFreq, minFreq, freqToX, handleTrackH };

            // If no data, draw filter handles on empty axes and return
            if (!data || data.length === 0) {
                drawFilterOverlay(specCtx, pad, plotW, plotH, w, h, dpr, freqToX, handleTrackH);
                return;
            }

            const spectrum = computeSpectrum(data, nChannels, sampleRate);
            if (!spectrum) return;
            const { freqs, power, nBins } = spectrum;

            // Draw spectrum fill (area under curve)
            specCtx.beginPath();
            let started = false;
            let lastX = pad.left;

            for (let i = 1; i < nBins; i++) {
                const freq = freqs[i];
                if (freq > maxFreq) break;
                if (freq < 0.3) continue;
                const x = freqToX(freq);
                const db = Math.max(dbMin, Math.min(dbMax, power[i]));
                const y = pad.top + ((dbMax - db) / (dbMax - dbMin)) * plotH;

                if (!started) { specCtx.moveTo(x, pad.top + plotH); specCtx.lineTo(x, y); started = true; }
                else specCtx.lineTo(x, y);
                lastX = x;
            }
            specCtx.lineTo(lastX, pad.top + plotH);
            specCtx.closePath();
            const fillGrad = specCtx.createLinearGradient(0, pad.top, 0, pad.top + plotH);
            fillGrad.addColorStop(0, 'rgba(95,179,179,0.25)');
            fillGrad.addColorStop(1, 'rgba(95,179,179,0.02)');
            specCtx.fillStyle = fillGrad;
            specCtx.fill();

            // Draw spectrum line
            specCtx.strokeStyle = '#5FB3B3';
            specCtx.lineWidth = 1.5 * dpr;
            specCtx.beginPath();
            started = false;

            for (let i = 1; i < nBins; i++) {
                const freq = freqs[i];
                if (freq > maxFreq) break;
                if (freq < 0.3) continue;
                const x = freqToX(freq);
                const db = Math.max(dbMin, Math.min(dbMax, power[i]));
                const y = pad.top + ((dbMax - db) / (dbMax - dbMin)) * plotH;

                if (!started) { specCtx.moveTo(x, y); started = true; }
                else specCtx.lineTo(x, y);
            }
            specCtx.stroke();

            // Cache the base layer (grid + curve, no filter overlay) for cheap redraws during drag
            if (!_spectrumBaseCanvas) _spectrumBaseCanvas = document.createElement('canvas');
            _spectrumBaseCanvas.width = w;
            _spectrumBaseCanvas.height = h;
            _spectrumBaseCanvas.getContext('2d').drawImage(spectrumCanvas, 0, 0);

            // Draw filter overlay and handles
            drawFilterOverlay(specCtx, pad, plotW, plotH, w, h, dpr, freqToX, handleTrackH);

            // Cache state for hover
            lastSpectrumState = { freqs, power, nBins, pad, plotW, plotH, w, h, dpr, dbMin, dbMax, maxFreq, minFreq, freqToX, handleTrackH };

            // Draw hover overlay if active
            if (spectrumHoverX >= 0) drawSpectrumHover(spectrumHoverVisible);
        }

        function drawSpectrumHover(showLabel) {
            const s = lastSpectrumState;
            if (!s || spectrumHoverX < 0 || !s.freqs) return;
            const { freqs, power, nBins, pad, plotW, plotH, dpr, dbMin, dbMax, maxFreq, minFreq, freqToX } = s;

            // Convert CSS mouse X to canvas X
            const cx = spectrumHoverX * dpr;
            if (cx < pad.left || cx > pad.left + plotW) return;

            // Reverse freqToX: cx = pad.left + ((sqrt(f) - sqrt(minFreq)) / (sqrt(maxFreq) - sqrt(minFreq))) * plotW
            const ratio = (cx - pad.left) / plotW;
            const sqrtF = Math.sqrt(minFreq) + ratio * (Math.sqrt(maxFreq) - Math.sqrt(minFreq));
            const hoverFreq = sqrtF * sqrtF;

            // Find closest bin
            let closestBin = 1;
            let closestDist = Infinity;
            for (let i = 1; i < nBins; i++) {
                if (freqs[i] > maxFreq) break;
                const d = Math.abs(freqs[i] - hoverFreq);
                if (d < closestDist) { closestDist = d; closestBin = i; }
            }

            const freq = freqs[closestBin];
            const db = Math.max(dbMin, Math.min(dbMax, power[closestBin]));
            const lineX = freqToX(freq);
            const lineY = pad.top + ((dbMax - db) / (dbMax - dbMin)) * plotH;

            // Vertical crosshair line (always shown)
            specCtx.strokeStyle = 'rgba(255,255,255,0.2)';
            specCtx.lineWidth = 1;
            specCtx.beginPath();
            specCtx.moveTo(lineX, pad.top);
            specCtx.lineTo(lineX, pad.top + plotH);
            specCtx.stroke();

            // Dot on the line (always shown)
            specCtx.fillStyle = '#5FB3B3';
            specCtx.beginPath();
            specCtx.arc(lineX, lineY, 3 * dpr, 0, Math.PI * 2);
            specCtx.fill();

            // Label only shown after pause, with fade-in opacity
            if (!showLabel) return;
            const opacity = spectrumLabelOpacity;

            const label = `${freq.toFixed(1)} Hz  ${db.toFixed(1)} dB`;
            specCtx.font = `bold ${11 * dpr}px 'IBM Plex Mono', monospace`;
            const textW = specCtx.measureText(label).width;

            // Position above the line, or below if too close to top
            const aboveY = lineY - 8 * dpr;
            const belowY = lineY + 14 * dpr;
            const textY = aboveY > pad.top + 14 * dpr ? aboveY : belowY;

            // Center on lineX, but clamp to plot area
            let textX = lineX;
            const halfW = textW / 2 + 4 * dpr;
            if (textX - halfW < pad.left) textX = pad.left + halfW;
            if (textX + halfW > pad.left + plotW) textX = pad.left + plotW - halfW;

            // Background pill
            specCtx.fillStyle = `rgba(10,10,26,${0.55 * opacity})`;
            specCtx.beginPath();
            const pillX = textX - textW / 2 - 4 * dpr;
            const pillY = textY - 8 * dpr;
            const pillW = textW + 8 * dpr;
            const pillH = 12 * dpr;
            specCtx.roundRect(pillX, pillY, pillW, pillH, 3 * dpr);
            specCtx.fill();

            // Text
            specCtx.fillStyle = `rgba(95,179,179,${opacity})`;
            specCtx.textAlign = 'center';
            specCtx.textBaseline = 'middle';
            specCtx.fillText(label, textX, textY - 2 * dpr);
        }

        // Spectrum hover events: crosshair immediate, label after 200ms pause with fade-in
        let spectrumHoverTimer = null;
        let spectrumHoverVisible = false;
        let spectrumLabelOpacity = 0;
        let spectrumFadeAnim = null;

        function startLabelFade() {
            spectrumHoverVisible = true;
            spectrumLabelOpacity = 0;
            const startTime = performance.now();
            const fadeDuration = 200;
            function fadeStep(now) {
                spectrumLabelOpacity = Math.min(1, (now - startTime) / fadeDuration);
                if (window._lastSpectrumArgs) drawSpectrum(...window._lastSpectrumArgs);
                if (spectrumLabelOpacity < 1 && spectrumHoverVisible) {
                    spectrumFadeAnim = requestAnimationFrame(fadeStep);
                } else {
                    spectrumFadeAnim = null;
                }
            }
            spectrumFadeAnim = requestAnimationFrame(fadeStep);
        }

        // Convert CSS x position on spectrum canvas to frequency (reverse of freqToX)
        function spectrumXToFreq(cssX) {
            const s = lastSpectrumState;
            if (!s) return null;
            const cx = cssX * s.dpr;
            const ratio = Math.max(0, Math.min(1, (cx - s.pad.left) / s.plotW));
            const sqrtF = Math.sqrt(s.minFreq) + ratio * (Math.sqrt(s.maxFreq) - Math.sqrt(s.minFreq));
            return sqrtF * sqrtF;
        }

        // Check if CSS position is near a filter handle (returns 'hp', 'lp', or null)
        function hitTestFilterHandle(cssX, cssY) {
            const s = lastSpectrumState;
            if (!s) return null;
            const trackH = s.handleTrackH / s.dpr;
            if (cssY > trackH + 6) return null;

            const hpCssX = s.freqToX(highPassFreq) / s.dpr;
            const lpCssX = s.freqToX(lowPassFreq) / s.dpr;
            const hitRadius = 14;

            const hpDist = Math.abs(cssX - hpCssX);
            const lpDist = Math.abs(cssX - lpCssX);

            if (hpDist <= hitRadius && hpDist <= lpDist) return 'hp';
            if (lpDist <= hitRadius) return 'lp';
            return null;
        }

        const MIN_FILTER_GAP = 1.0; // Hz ‚Äî minimum gap between HP and LP

        // Apply filter state changes to waveform and audio nodes
        function applyFilterChange() {
            minimapCacheDirty = true;
            // Update audio filter nodes immediately (cheap)
            if (highPassFilterNode) highPassFilterNode.frequency.value = highPassEnabled ? highPassFreq * 44.1 : 0;
            if (lowPassFilterNode) lowPassFilterNode.frequency.value = lowPassEnabled ? lowPassFreq * 44.1 : 22050;
            if (scrubHPFilter) scrubHPFilter.frequency.value = highPassEnabled ? highPassFreq * 44.1 : 0;
            if (scrubLPFilter) scrubLPFilter.frequency.value = lowPassEnabled ? lowPassFreq * 44.1 : 22050;

            // During playback or filter drag, the animation loop / mousemove handler covers redraws
            if (isPlaying || filterDragging) return;

            // Full redraw (not playing, not dragging) ‚Äî use sync zero-alloc path
            if (regionData) {
                const viewEnd = Math.min(currentViewStart + VIEW_WINDOW, regionData.duration_seconds);
                const data = getDataFromCacheSync(currentViewStart, viewEnd);
                if (data && data.length > 0) {
                    const filtered = applyFilters(data, regionData.n_channels, regionData.sample_rate);
                    drawTimeRangeSync(currentViewStart, VIEW_WINDOW, filtered, true);
                    drawPlayhead();
                }
                drawMinimap();
            }
        }

        spectrumCanvas.addEventListener('mousedown', (e) => {
            const rect = spectrumCanvas.getBoundingClientRect();
            const cssX = e.clientX - rect.left;
            const cssY = e.clientY - rect.top;
            const hit = hitTestFilterHandle(cssX, cssY);
            if (hit) {
                filterDragging = hit;
                filterClickStart = { x: cssX, time: performance.now() };
                e.preventDefault();
            }
        });

        let _filterDragRAF = 0;
        document.addEventListener('mousemove', (e) => {
            if (!filterDragging) return;
            const rect = spectrumCanvas.getBoundingClientRect();
            const cssX = e.clientX - rect.left;
            const freq = spectrumXToFreq(cssX);
            if (freq === null) return;

            if (filterDragging === 'hp') {
                if (!highPassEnabled) highPassEnabled = true;
                const maxHP = lowPassEnabled ? lowPassFreq - MIN_FILTER_GAP : 499;
                highPassFreq = Math.max(0.1, Math.min(freq, maxHP));
            } else {
                if (!lowPassEnabled) lowPassEnabled = true;
                const minLP = highPassEnabled ? highPassFreq + MIN_FILTER_GAP : 0.2;
                lowPassFreq = Math.max(minLP, Math.min(freq, 500));
            }

            // Update audio nodes immediately (cheap)
            if (highPassFilterNode) highPassFilterNode.frequency.value = highPassEnabled ? highPassFreq * 44.1 : 0;
            if (lowPassFilterNode) lowPassFilterNode.frequency.value = lowPassEnabled ? lowPassFreq * 44.1 : 22050;
            if (scrubHPFilter) scrubHPFilter.frequency.value = highPassEnabled ? highPassFreq * 44.1 : 0;
            if (scrubLPFilter) scrubLPFilter.frequency.value = lowPassEnabled ? lowPassFreq * 44.1 : 22050;
            // DON'T set minimapCacheDirty here ‚Äî deferred to mouseup.
            // Setting it per-mousemove causes rebuildMinimapCache (3.6M samples filtered)
            // to run every animation frame during drag.

            // During drag: ONLY update the spectrum filter handle overlay.
            // Waveform + minimap are deferred to mouseup ‚Äî they're too expensive per-frame.
            if (!_filterDragRAF) {
                _filterDragRAF = requestAnimationFrame(() => {
                    _filterDragRAF = 0;
                    redrawSpectrumOverlay();
                });
            }
        });

        document.addEventListener('mouseup', (e) => {
            if (!filterDragging) return;
            const rect = spectrumCanvas.getBoundingClientRect();
            const cssX = e.clientX - rect.left;
            const wasClick = filterClickStart &&
                Math.abs(cssX - filterClickStart.x) < 3 &&
                (performance.now() - filterClickStart.time) < 300;

            if (wasClick) {
                if (filterDragging === 'hp') highPassEnabled = !highPassEnabled;
                else lowPassEnabled = !lowPassEnabled;
                applyFilterChange();
            }

            filterDragging = null;
            filterClickStart = null;
            // Now that drag is done: mark minimap dirty and do full redraws
            minimapCacheDirty = true;
            if (window._lastSpectrumArgs) drawSpectrum(...window._lastSpectrumArgs);
            if (regionData && !isPlaying) {
                const viewEnd = Math.min(currentViewStart + VIEW_WINDOW, regionData.duration_seconds);
                const data = getDataFromCacheSync(currentViewStart, viewEnd);
                if (data && data.length > 0) {
                    const filtered = applyFilters(data, regionData.n_channels, regionData.sample_rate);
                    drawTimeRangeSync(currentViewStart, VIEW_WINDOW, filtered, true);
                    drawPlayhead();
                }
            }
            drawMinimap();
        });

        // Cursor + hover: handle track gets grab cursor, plot area gets crosshair + hover
        spectrumCanvas.addEventListener('mousemove', (e) => {
            const rect = spectrumCanvas.getBoundingClientRect();
            const cssX = e.clientX - rect.left;
            const cssY = e.clientY - rect.top;

            if (filterDragging) {
                spectrumCanvas.style.cursor = 'grabbing';
                spectrumHoverX = -1;
                return;
            }

            const hit = hitTestFilterHandle(cssX, cssY);
            if (hit) {
                spectrumCanvas.style.cursor = 'grab';
                spectrumHoverX = -1;
                if (spectrumHoverTimer) { clearTimeout(spectrumHoverTimer); spectrumHoverTimer = null; }
                spectrumHoverVisible = false;
                spectrumLabelOpacity = 0;
                if (window._lastSpectrumArgs) drawSpectrum(...window._lastSpectrumArgs);
                return;
            }

            spectrumCanvas.style.cursor = 'crosshair';
            spectrumHoverX = cssX;

            if (spectrumHoverVisible) {
                if (window._lastSpectrumArgs) drawSpectrum(...window._lastSpectrumArgs);
                return;
            }

            if (spectrumHoverTimer) clearTimeout(spectrumHoverTimer);
            spectrumHoverTimer = setTimeout(() => { startLabelFade(); }, 200);
            if (window._lastSpectrumArgs) drawSpectrum(...window._lastSpectrumArgs);
        });

        spectrumCanvas.addEventListener('mouseleave', () => {
            if (spectrumHoverTimer) clearTimeout(spectrumHoverTimer);
            spectrumHoverTimer = null;
            if (spectrumFadeAnim) cancelAnimationFrame(spectrumFadeAnim);
            spectrumFadeAnim = null;
            spectrumHoverX = -1;
            spectrumHoverVisible = false;
            spectrumLabelOpacity = 0;
            if (window._lastSpectrumArgs) drawSpectrum(...window._lastSpectrumArgs);
        });

        // Draw empty spectrum axes on load
        drawSpectrum(null, 0, 0);

        // Start
        init();
    </script>
</body>
</html>
